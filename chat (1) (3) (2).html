<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>FlabsAI</title>
    <link rel="icon" href="https://s6.imgcdn.dev/YsWz8D.png" type="image/x-icon">
    <!-- CDN Font dari Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@400;500;600;700;800&family=Roboto:wght@400;500;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- CDN Ikon dari Flaticon -->
    <link rel='stylesheet' href='https://cdn-uicons.flaticon.com/2.4.2/uicons-bold-rounded/css/uicons-bold-rounded.css'>
    <link rel='stylesheet' href='https://cdn-uicons.flaticon.com/2.4.2/uicons-solid-rounded/css/uicons-solid-rounded.css'>
    <link rel='stylesheet' href='https://cdn-uicons.flaticon.com/2.4.2/uicons-regular-rounded/css/uicons-regular-rounded.css'>

    <script>
      // Synchronous script for immediate dark mode check
      (function() {
        try {
          let useDarkMode = false;
          const storedDarkMode = localStorage.getItem('darkMode');

          if (storedDarkMode === 'true') {
            useDarkMode = true;
          } else if (storedDarkMode === null) {
            // First time user: default to dark mode
            useDarkMode = true;
            localStorage.setItem('darkMode', 'true');
          }
          // If storedDarkMode is 'false', useDarkMode remains false (light mode)

          if (useDarkMode) {
            document.documentElement.classList.add('dark-mode');
            document.documentElement.style.backgroundColor = '#121212';
          } else {
            document.documentElement.style.backgroundColor = 'white';
          }
        } catch (e) { console.warn('Could not access localStorage for dark mode check.'); }
      })();
    </script>
    <style>
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color, white); /* Ensure HTML has base background */
            font-size: 15.5px; 
            overflow: hidden; /* Prevent html scroll */
        }

        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: var(--font-main, 'Poppins', sans-serif); 
            font-weight: 500;
            background-color: var(--bg-color, white);
            color: var(--text-color, #050505); 
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s, color 0.3s;
            overflow: hidden; 
            font-size: 0.95rem; 
        }

        :root {
            --message-font-size-multiplier: 1.0;
            --font-main: 'Poppins', sans-serif;
            --font-primary: 'Poppins', sans-serif;
            --font-subtext-hero: 'Baloo 2', sans-serif;
            --font-alt: 'Roboto', sans-serif;
            
            /* Dark Mode Colors */
            --bg-color: #0c0c0e; 
--surface-color: #18181B; 
            --text-color: #e8eaed; 
            --secondary-text-color: #a8adb4;
            --border-color: #303134; 
            --bg-color-rgb: 12, 12, 14; 
            --text-color-rgb: 232, 234, 237; 
            --secondary-text-color-rgb: 168, 173, 180;
            
            /* Dark Mode Glass */
            --glass-bg: rgba(38, 38, 42, 0.45);
            --glass-blur: 8px; 
            --glass-border-color: rgba(60, 60, 65, 0.4); 
            --glass-shadow: 0 5px 15px -4px rgba(0,0,0,0.3), inset 0 0.3px 0.3px rgba(255,255,255,0.05); 
            --glass-sheen: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.04) 50%, rgba(255,255,255,0) 100%);
            --glass-icon-button-hover-bg: rgba(52, 52, 57, 0.55);

            /* Dot Grid */
            --dot-grid-color: rgba(var(--secondary-text-color-rgb), 0.1);
            --dot-size: 1px;
            --dot-spacing: 25px;

            /* General UI */
            --header-height: 56px;
            --safe-area-inset-top: env(safe-area-inset-top, 0px);
            --safe-area-inset-right: env(safe-area-inset-right, 0px);
            --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
            --safe-area-inset-left: env(safe-area-inset-left, 0px);
            --dialog-overlay-bg: rgba(0,0,0,0.65);
            --button-bg-color: #1877f2;
            --button-text-color: #ffffff;
            --stop-button-bg-color: #dc3545;
            --stop-button-hover-bg-color: #c82333;
        }

        body::before { 
            content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 130%, rgba(var(--secondary-text-color-rgb), 0.35) 0%, transparent 70%),
                        radial-gradient(circle at 50% 50%, rgba(var(--secondary-text-color-rgb), 0.025) 0%, transparent 40%);
            z-index: 3; pointer-events: none;
            transition: background 0.5s ease;
        }

        * { box-sizing: border-box; }

        i[class^="fi-"] { 
            font-size: 19px; 
            line-height: 1;
            vertical-align: middle;
            color: currentColor; 
            display: inline-flex; 
            align-items: center; 
            justify-content: center; 
        }
        
        #app-layout-container {
            width:100%;
            height:100%; 
            display:flex;
            flex-direction:column;
            overflow: hidden; 
            opacity: 0; 
            transition: opacity 0.8s ease-in-out;
            background-color: var(--bg-color); 
            position: relative; 
        }
        
        #app-layout-container.visible {
            opacity: 1;
        }
        
        body.voice-input-active > #app-layout-container:not(#app-layout-container::before) { 
            user-select: none;
        }
        body.voice-input-active > #app-layout-container > *:not(#input-area-wrapper) {
            pointer-events: none;
        }

        #app-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 101;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 16px;
            padding-top: calc(10px + var(--safe-area-inset-top));
            padding-left: calc(16px + var(--safe-area-inset-left));
            padding-right: calc(16px + var(--safe-area-inset-right));
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            opacity: 0;
            transform: translateY(-20px);
        }
        #app-header.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #profile-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background-color: var(--surface-color); /* Solid background */
            border: 1px solid var(--border-color); /* Standard border */
            border-radius: 12px;
            color: var(--text-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.15); /* Standard shadow */
            position: relative;
            overflow: hidden;
            height: 36px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
        }
        #profile-container:hover {
            background-color: #27272a; /* Solid hover */
            border-color: var(--secondary-text-color);
        }

        #profile-pic-container {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            overflow: hidden;
            flex-shrink: 0;
        }
        #profile-pic-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #profile-text {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-color);
            white-space: nowrap;
        }

        .header-control-btn {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 36px;
            height: 36px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border-color);
            border-radius: 12px;
            color: var(--text-color);
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            box-shadow: var(--glass-shadow);
            position: relative;
            overflow: hidden;
            margin-left: 8px;
        }
        .header-control-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -80%;
            width: 60%;
            height: 100%;
            background: var(--glass-sheen);
            transform: skewX(-25deg);
            pointer-events: none;
            opacity: 0.8;
        }
        .header-control-btn:hover:not(:disabled) {
            background-color: var(--glass-icon-button-hover-bg);
            border-color: var(--text-color);
        }
        .header-control-btn:disabled {
             opacity: 0.4 !important; cursor: not-allowed !important;
             color: var(--secondary-text-color) !important;
             background-color: transparent !important;
        }
        .header-control-btn i {
            font-size: 20px; 
            line-height: 1;
            position: relative;
            top: 1px; /* Penyesuaian Posisi Vertikal */
        }

        .modal-close-btn i {
            position: relative;
            top: 1px; /* Penyesuaian Posisi Vertikal */
        }

        #app-header-tools-container {
            position: relative;
            flex-shrink: 0;
            display: flex; 
            align-items: center;
        }

        #tools-dropdown-menu, #new-chat-confirm-menu, #user-message-context-menu {
            display: none;
            position: absolute;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border-color);
            border-radius: 14px;
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            box-shadow: var(--glass-shadow);
            padding: 6px;
            z-index: 1005;
            width: max-content;
            transition: background-color 0.3s, box-shadow 0.3s, border-color 0.3s, backdrop-filter 0.3s;
        }

        #tools-dropdown-menu {
            top: calc(100% + 8px);
            right: 0;
            min-width: 180px;
        }

        #new-chat-confirm-menu {
            top: calc(100% + 8px);
            right: 44px; /* Disesuaikan */
            min-width: 160px;
        }

        #user-message-context-menu {
            min-width: 150px;
        }

        #tools-dropdown-menu button, #new-chat-confirm-menu button, #user-message-context-menu button {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            padding: 8px 10px;
            background: none;
            border: none;
            text-align: left;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            color: var(--text-color);
            border-radius: 8px; /* Sudut lebih bulat */
            transition: background-color 0.2s, color 0.2s;
        }

        #tools-dropdown-menu button i, #new-chat-confirm-menu button i, #user-message-context-menu button i {
            font-size: 16px;
            line-height: 1;
            flex-shrink: 0;
            width: 20px;
            text-align: center;
        }
        
        #tools-dropdown-menu button:hover:not(:disabled), 
        #new-chat-confirm-menu button:hover:not(:disabled), 
        #user-message-context-menu button:hover:not(:disabled) {
            background-color: var(--glass-icon-button-hover-bg);
        }

        #tools-dropdown-menu button:not(:last-child), #user-message-context-menu button:not(:last-child) {
            margin-bottom: 3px; 
        }

        #tools-dropdown-menu button:disabled, #new-chat-confirm-menu button:disabled, #user-message-context-menu button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }


        #main-logo-header {
            display: none; /* Awalnya disembunyikan, ditampilkan oleh JS */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0 15px;
            margin-top: calc(var(--header-height) + var(--safe-area-inset-top) + 100px); 
            color: var(--text-color);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease-out 0.1s, transform 0.5s ease-out 0.1s;
        }
        #main-logo-header.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* CSS Baru untuk teks tengah */
        #main-logo-header h2 {
            font-size: 1.8em;
            font-weight: 700;
            color: var(--secondary-text-color);
            margin: 0;
        }

        @media (max-width: 480px) {
            #main-logo-header h2 {
                font-size: 1.5em;
            }
        }


        #quick-actions-carousel-wrapper {
            width: 100%;
            position: relative;
            margin: 35px auto 0 auto; 
            padding: 0 0 5px 0; 
            height: auto; 
            min-height: 290px; 
            display: flex;
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-start; 
            overflow: visible; 
            perspective: 1600px; 
            background-color: var(--card-slider-primary-bg);
            transition: background-color 0.3s, opacity 0.5s ease-in;
            opacity: 0; 
            z-index: 1;
            transform: translateY(20px);
            transition: opacity 0.5s ease-out 0.2s, transform 0.5s ease-out 0.2s;
        }
        #quick-actions-carousel-wrapper.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #quick-actions-title-container {
            text-align: center;
            margin-bottom: 25px; 
            width: 90%;
            max-width: 600px;
            opacity: 0; 
            transition: opacity 0.5s ease-in 0.2s; 
            padding-top: 10px; 
        }
        #quick-actions-title-container.visible {
            opacity: 1;
        }
        #quick-actions-title-text {
            font-size: 1.2em; 
            font-weight: 600;
            margin: 0;
            color: var(--text-color);
            line-height: 1.4; 
        }


        .quick-actions-gallery-container {
            position: relative;
            transform-style: preserve-3d;
            width: 140px;  
            height: 185px; 
            transition: width 0.3s, height 0.3s;
            margin-top: 5px; 
        }
        
        body.dark-mode .action-card-info h3 {
            color: var(--text-color); 
        }
        body.dark-mode .action-card-info p {
            color: var(--secondary-text-color);
        }
        
        .action-card {
            width: 100%;
            height: 100%;
            margin: 0;
            background-color: var(--surface-color); /* Solid background */
            border: 1px solid var(--border-color); /* Standard border */
            border-radius: 14px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15); /* Standard shadow */
            overflow: hidden;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 12px;
            position: absolute;
            top: 0; left: 0;
            transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.5s ease, box-shadow 0.5s ease, border-color 0.3s, background-color 0.3s;
            transform-origin: center center;
            flex-shrink: 0;
            font-family: var(--font-subtext-hero);
            gap: 5px;
        }

        .action-card-icon-container {
            width: 42px;  
            height: 42px; 
            margin-bottom: 4px; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .action-card-icon-container i { 
            font-size: 26px; 
            transition: color 0.3s;
        }
        .action-card-info h3 {
            font-family: var(--font-secondary-slider);
            margin: 0 0 3px 0; 
            font-size: 1.0em;  
            font-weight: 600;
            line-height: 1.2;
            color: var(--card-slider-text-primary);
            transition: color 0.3s;
        }
        .action-card-info p.action-card-subtext { /* Modified for "klik saya" */
            margin: 0;
            font-size: 0.7em; 
            color: var(--card-slider-text-secondary);
            transition: color 0.3s;
            font-weight: 600;
            min-height: 1em; /* Ensure space even if empty */
        }
        
        .action-card.active {
            transform: translateX(0) scale(1.03) rotateY(0deg) translateZ(40px); 
            z-index: 10;
            opacity: 1;
            box-shadow: 0 6px 15px var(--card-slider-card-shadow-dark); 
            pointer-events: auto;
        }
        body.dark-mode .action-card.active {
             box-shadow: 0 6px 15px rgba(0,0,0,0.25); 
        }
        
        .action-card.prev {
            transform: translateX(-50%) scale(0.8) rotateY(30deg) translateZ(-25px); 
            opacity: 0.60; 
            z-index: 8;
            pointer-events: auto;
        }
        
        .action-card.next {
            transform: translateX(50%) scale(0.8) rotateY(-30deg) translateZ(-25px); 
            opacity: 0.60; 
            z-index: 8;
            pointer-events: auto;
        }
        
        .action-card.far-prev {
            transform: translateX(-95%) scale(0.65) rotateY(35deg) translateZ(-65px); 
            opacity: 0.18; 
            z-index: 5;
            pointer-events: none;
        }
        
        .action-card.far-next {
            transform: translateX(95%) scale(0.65) rotateY(-35deg) translateZ(-65px); 
            opacity: 0.18; 
            z-index: 5;
            pointer-events: none;
        }
        
        .action-card.very-far-prev, .action-card.very-far-next {
            transform: scale(0.55) translateZ(-100px); 
            opacity: 0; 
            z-index: 1;
            pointer-events: none;
        }
        
        .quick-actions-carousel-dots-container {
            display: none !important; 
            text-align: center; 
            padding: 4px 0 8px 0;
            position: relative;
            z-index: 1;
            background-color: var(--card-slider-primary-bg);
            transition: background-color 0.3s;
        }
        .quick-actions-carousel-dot {
            display: inline-block; 
            width: 7px; height: 7px;
            border-radius: 50%; 
            background-color: var(--card-slider-dot-color); 
            margin: 0 3px;
            cursor: pointer; 
            transition: background-color 0.3s ease, transform 0.3s ease; 
        }
        .quick-actions-carousel-dot.active { 
            background-color: var(--card-slider-dot-active-color); 
            transform: scale(1.15);
        }

        #quick-actions-swipe-hint {
            display: none !important; 
            text-align: center;
            font-size: 0.75em;
            color: var(--secondary-text-color);
            padding-bottom: 8px;
            font-family: var(--font-secondary-slider);
            font-weight: 600;
            background-color: var(--card-slider-primary-bg);
            transition: background-color 0.3s, color 0.3s;
            position: relative;
            z-index: 1;
        }

        @media (max-width: 768px) {
            #quick-actions-carousel-wrapper { min-height: 280px; perspective: 1300px; } 
            .quick-actions-gallery-container { width: 130px; height: 170px; } 
            .action-card.active { transform: translateX(0) scale(1) rotateY(0deg) translateZ(30px); }
            .action-card.prev { transform: translateX(-52%) scale(0.75) rotateY(28deg) translateZ(-20px); }
            .action-card.next { transform: translateX(52%) scale(0.75) rotateY(-28deg) translateZ(-20px); }
            .action-card.far-prev { transform: translateX(-98%) scale(0.6) rotateY(30deg) translateZ(-55px); opacity: 0.15; }
            .action-card.far-next { transform: translateX(98%) scale(0.6) rotateY(-30deg) translateZ(-55px); opacity: 0.15; }
            
            .action-card-icon-container { width: 40px; height: 40px; }
            .action-card-icon-container i { font-size: 24px; }
            .action-card-info h3 { font-size: 0.9em; }
            .action-card-info p.action-card-subtext { font-size: 0.65em; }
        }
         @media (max-width: 480px) {
            #quick-actions-carousel-wrapper { min-height: 250px; perspective: 1100px; margin-top: 25px;} 
            #quick-actions-title-text { font-size: 1.1em; } 
            .quick-actions-gallery-container { width: 115px; height: 150px; } 
            .action-card.active { transform: translateX(0) scale(1) rotateY(0deg) translateZ(20px); }
            .action-card.prev { transform: translateX(-55%) scale(0.7) rotateY(25deg) translateZ(-15px); }
            .action-card.next { transform: translateX(55%) scale(0.7) rotateY(-25deg) translateZ(-15px); }
            .action-card.far-prev { transform: translateX(-100%) scale(0.55) rotateY(28deg) translateZ(-45px); opacity: 0.1; }
            .action-card.far-next { transform: translateX(100%) scale(0.55) rotateY(-28deg) translateZ(-45px); opacity: 0.1; }

            .action-card-icon-container { width: 36px; height: 36px; }
            .action-card-icon-container i { font-size: 22px; }
            .action-card-info h3 { font-size: 0.85em; } 
            .action-card-info p.action-card-subtext { font-size: 0.6rem; }
            .action-card { padding: 10px; gap: 4px; border-radius: 12px; }
        }

        #chat-container {
          flex-grow: 1; 
          width: 100%; max-width: 760px; margin: 0 auto; 
          padding: calc(var(--header-height) + var(--safe-area-inset-top) + 24px) 12px 0 12px;
          padding-bottom: 200px;
          overflow-y: auto; overflow-x: hidden; display: flex; flex-direction: column;
          gap: 12px; 
          will-change: scroll-position; background-color: transparent; 
          mask-image: linear-gradient(to bottom, transparent 0%, black 50px ); /* MODIFIED: Made top fade darker */
          -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 50px ); /* MODIFIED: Made top fade darker */
          scrollbar-width: none; 
          -ms-overflow-style: none;  
          position: relative; 
          z-index: 2; 
          min-height: 0; 
        }
        #chat-container::-webkit-scrollbar { 
            width: 0px; 
            height: 0px; 
            background: transparent; 
        }
        
        #dot-grid-background { 
            content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-image: radial-gradient(var(--dot-grid-color) var(--dot-size), transparent var(--dot-size));
            background-size: var(--dot-spacing) var(--dot-spacing);
            z-index: 1;
        }

        #bottom-vignette {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 80px; 
            background: linear-gradient(to top, rgba(var(--bg-color-rgb), 0.4) 0%, rgba(var(--bg-color-rgb), 0) 100%);
            z-index: 49; pointer-events: none; transition: background 0.3s;
        }

        .message {
          display: flex; max-width: 98%; align-items: flex-end; 
          position: relative; 
          margin-bottom: 18px;
          opacity: 0;
          transform: translateY(15px) scale(0.98);
          animation: messageFadeInBounce 0.45s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
          -webkit-user-select: none; /* Safari */
          -ms-user-select: none; /* IE 10+ */
          user-select: none; /* Standard syntax */
        }
        .message.editing-hidden {
            display: none !important;
        }
        @keyframes messageFadeInBounce {
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .ai-message .message-content {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border-color);
            border-radius: 18px;
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            box-shadow: var(--glass-shadow);
            padding: 10px 15px;
            line-height: 1.6;
            font-size: calc(0.9rem * var(--message-font-size-multiplier, 1));
            font-weight: 500;
            overflow-wrap: break-word;
            word-break: break-word;
            max-width: 100%;
            transition: color 0.3s, background-color 0.3s, border-color 0.3s, box-shadow 0.3s, backdrop-filter 0.3s;
            color: var(--text-color);
            min-width: 150px;
            border-bottom-left-radius: 5px;
        }
        .ai-message .message-content p {
            font-size: inherit;
            line-height: inherit;
        }
        .ai-word-animated, .ai-html-animated {
            opacity: 0;
            transition: opacity 0.15s ease-in-out;
            display: inline;
        }
        .ai-html-animated {
            display: block;
        }
        .ai-message.error-message .message-content {
            background-color: #ffebee;
            color: #c62828;
            border: 1px solid #ef9a9a;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }
        body.dark-mode .ai-message.error-message .message-content {
            background-color: #5e3333;
            color: #ff8a80;
            border-color: #c35050;
        }
        .ai-message .message-content.bordered-text-loader {
            border: 1px solid var(--border-color);
            padding: 7px 13px; 
            border-radius: 12px;
            display: inline-block;
            background-color: transparent; 
            font-size: 0.9em; 
            color: var(--secondary-text-color);
            font-weight: 600;
            line-height: 1.4;
            box-shadow: none;
            min-width: 0; /* Reset min-width for loaders */
        }


        .message-content p { margin: 0 0 8px 0; } .message-content p:last-child { margin-bottom: 0; } 
        .message-content ul, .message-content ol { margin: 8px 0 8px 20px; padding-left: 14px; } 
        .message-content li { margin-bottom: 4px; } 
        .message-content b, .message-content strong { font-weight: 700; } 
        .message-content sup, .message-content sub { line-height: 0; } 
        .message-content a { color: var(--user-message-bg); text-decoration: none; font-weight: 700;} 
        body.dark-mode .message-content a { color: var(--button-bg-color); }
        .message-content a:hover { text-decoration: underline; }
        .message-content small i, .message-content .stopped-text, .message-content .fetching-text {
            font-size: 0.85em; color: var(--secondary-text-color); font-weight: 600; 
        }
        .image-process-progress-bar-container {
            width: 100%;
            background-color: var(--progress-bar-container-bg);
            border-radius: 5px; 
            overflow: hidden;
            height: 18px; 
            margin-top: 8px; 
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.08); 
        }
        .image-process-progress-bar {
            width: 0%;
            height: 100%;
            background-color: var(--progress-bar-fill-color);
            text-align: center;
            line-height: 18px; 
            color: white;
            border-radius: 5px 0 0 5px; 
            transition: width 0.25s ease-in-out;
            font-size: 0.75em; font-weight: 600; 
        }
        .image-process-status-text {
            font-size: 0.8em; 
            color: var(--secondary-text-color);
            margin-top: 4px; 
            text-align: center;
            font-weight: 600;
        }
        .pollinations-image-display-container .thinking-loader { 
            padding: 20px 0; 
            margin-top: 8px; 
            margin-bottom: 8px; 
        }

        .user-sent-attachment-display {
            display: flex;
            flex-wrap: wrap; 
            gap: 8px;  
            margin-top: 8px; 
            max-width: 100%;
        }
        .user-sent-attachment-entry {
            width: 70px;  
            height: 70px; 
            border-radius: 7px; 
            overflow: hidden;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg-color);
            position: relative; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
         .user-sent-attachment-entry img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .user-sent-attachment-entry .file-icon-preview i {
          margin-top: 10px;
          justify-content: center;
          align-items: center;
            font-size: 24px;  
            color: var(--icon-fill-color);
        }
         .user-message .user-sent-attachment-display { 
             background-color: transparent;
             padding: 0;
        }
         .user-message .attachment-name { display: none; }


        .user-message { align-self: flex-end; margin-left: auto; }
        .user-message .message-content {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border-color);
            border-radius: 18px;
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            box-shadow: var(--glass-shadow);
            color: var(--text-color);
            padding: 10px 15px;
            line-height: 1.55;
            font-size: calc(0.9rem * var(--message-font-size-multiplier, 1));
            font-weight: 500;
            border-bottom-right-radius: 5px;
            position: relative;
            min-width: auto;
            display: inline-block;
            cursor: pointer;
            overflow-wrap: break-word;
            word-break: break-word;
            transition: color 0.3s, background-color 0.3s, border-color 0.3s, box-shadow 0.3s, backdrop-filter 0.3s;
        }

        .ai-message { align-self: flex-start; margin-right: auto; }
        

        .pollinations-image-display-container {
            margin-top: 8px; 
            max-width: 100%;
        }
        .pollinations-image-display-container img.pollinations-generated-image,
        .pollinations-image-display-container canvas.processed-image-canvas {
            display: block;
            max-width: 100%;
            max-height: 450px; 
            border-radius: 8px; 
            border: 1px solid var(--border-color);
            background-color: var(--pollinations-image-container-bg);
            object-fit: contain;
        }
        .pollinations-image-display-container.loading-initial img.pollinations-generated-image,
        .pollinations-image-display-container.loading-initial canvas.processed-image-canvas {
            display: none;
        }
        .ai-message .pollinations-image-display-container .image-prompt-display {
            font-size: 0.9em; 
            font-style: italic;
            color: var(--secondary-text-color);
            margin-bottom: 8px; 
            word-break: break-word;
            padding: 4px 6px;  
            background-color: rgba(0,0,0,0.02); 
            border-radius: 4px;
            display: inline-block; 
            font-weight: 600; 
        }
        body.dark-mode .ai-message .pollinations-image-display-container .image-prompt-display {
             background-color: rgba(255,255,255,0.03);
        }

        .pollinations-image-display-container .image-meta-info {
            font-size: 0.75em; 
            color: var(--secondary-text-color);
            margin-top: 6px; 
            text-align: center;
            font-weight: 600;
        }
        .pollinations-support-text {
            font-size: 0.7em; 
            color: var(--secondary-text-color);
            text-align: center;
            margin-top: 4px; 
            font-weight: 600;
        }


        .system-info-message {
          align-self: center; width: fit-content; max-width: 75%; 
          margin-left: auto; margin-right: auto;
        }
        .system-info-message .message-content {
          background-color: var(--system-info-bg); color: var(--system-info-text);
          border: 1px solid var(--system-info-border); 
          font-size: calc(0.85em * var(--message-font-size-multiplier, 1));
          text-align: center; 
          padding: 9px 13px; border-radius: 10px; font-weight: 600; 
          overflow-wrap: break-word;
          word-break: break-word;
        }
        .message-actions-toolbar {
            position: absolute;
            bottom: -24px; 
            display: flex;
            gap: 6px; 
            z-index: 1;
            opacity: 0; /* Hidden by default */
            pointer-events: none; /* No interaction by default */
            transition: opacity 0.2s;
        }
        .message.actions-visible .message-actions-toolbar {
            opacity: 1;
            pointer-events: auto;
        }

        .ai-message .message-actions-toolbar { left: 0px; right: auto; }


        .message-action-btn {
            background: transparent; 
            color: var(--secondary-text-color);
            border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; 
            display: flex; align-items: center; justify-content: center;
            opacity: 0.7; /* Default opacity when toolbar is visible */
            transition: opacity 0.2s, color 0.2s, transform 0.1s ease-out;
            padding:0;
        }
        .message-action-btn:active {
            transform: scale(0.9);
        }
        .message.actions-visible .message-action-btn:hover { /* Only apply hover when parent is .actions-visible */
            opacity: 1;
            color: var(--text-color); 
        }
        .message-action-btn i {
            font-size: 16px; 
            color: currentColor; 
        }
        /* NEW: Style for active (liked/unliked) buttons */
        .message-action-btn.active {
            color: var(--button-bg-color);
            opacity: 1;
        }
        
        .message-edited-indicator {
            font-size: 0.7em;
            color: var(--secondary-text-color);
            font-style: italic;
            display: block;
            text-align: right;
            margin-top: 3px;
        }


        .message-action-btn.action-activated i {
            animation: actionButtonPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        @keyframes actionButtonPop {
            0% { transform: scale(1); }
            50% { transform: scale(1.6) rotate(10deg); color: var(--button-bg-color); } 
            100% { transform: scale(1); }
        }


        .artifact-container {
            background: var(--artifact-bg-light);
            -webkit-backdrop-filter: blur(7px) saturate(140%); 
            backdrop-filter: blur(7px) saturate(140%);
            border: 1px solid var(--artifact-border-light);
            border-radius: 10px;  
            margin-top: 8px; margin-bottom: 7px; overflow: hidden;  
            box-shadow: var(--artifact-shadow-light);
            transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s, opacity 0.3s;
            color: var(--text-color); 
            opacity: 0; 
        }
        body.dark-mode .artifact-container {
            background: var(--artifact-bg-dark);
            border-color: var(--artifact-border-dark);
            box-shadow: var(--artifact-shadow-dark);
        }

        .artifact-header {
            display: flex; justify-content: space-between; align-items: center; padding: 8px 12px;  
            background-color: transparent; 
            border-bottom: 1px solid var(--artifact-border-light); 
            font-size: 0.8em; font-weight: 700; color: var(--secondary-text-color); 
            transition: border-color 0.3s, color 0.3s;
            cursor: pointer; 
        }
        body.dark-mode .artifact-header {
             border-bottom-color: var(--artifact-border-dark);
        }
        .artifact-header .artifact-title { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-right: 7px; display: inline;} 
        .artifact-click-hint {
            font-size: 0.9em;  
            color: var(--secondary-text-color);
            font-style: italic;
            font-weight: normal;
            margin-left: 3px; 
            display: inline; 
        }
        #artifact-viewer-modal .artifact-click-hint { display: none; }

        .artifact-header-actions { display: flex; gap: 6px; }  
        .artifact-header-btn {
          background-color: var(--artifact-header-btn-bg); color: var(--secondary-text-color); border: none;
          padding: 6px; font-size: 0.9em; border-radius: 5px;  
          cursor: pointer;
          transition: background-color 0.2s, color 0.2s;
          display: flex; align-items: center; justify-content: center;
          line-height: 1;
        }
        .artifact-header-btn:hover { background-color: var(--artifact-header-btn-hover-bg); color: var(--text-color); }
        .artifact-header-btn i { font-size: 15px; }  

        .artifact-content { 
            padding: 9px 12px; font-size: 0.85em;  
            line-height: 1.5; max-height: 220px;  
            overflow-y: auto; 
            color: var(--text-color); font-weight: 500; 
        }
        .artifact-content::-webkit-scrollbar { width: 6px; }  
        .artifact-content::-webkit-scrollbar-track { background: rgba(0,0,0,0.03); border-radius: 8px; }
        body.dark-mode .artifact-content::-webkit-scrollbar-track { background: rgba(255,255,255,0.03); }
        .artifact-content::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb-color); border-radius: 8px; }
        .artifact-content::-webkit-scrollbar-thumb:hover { background: #a0a4a8; }
        body.dark-mode .artifact-content::-webkit-scrollbar-thumb:hover { background: #777b7e; }
        .artifact-content { scrollbar-width: thin; scrollbar-color: var(--scrollbar-thumb-color) rgba(0,0,0,0.03); }
        body.dark-mode .artifact-content { scrollbar-color: var(--scrollbar-thumb-color) rgba(255,255,255,0.03); }
        
        .code-artifact .artifact-content {
          background-color: rgba(45,45,45,0.8);  
          color: #f0f0f0; font-family: 'Courier New', Courier, monospace;
          border-radius: 0 0 8px 8px;  
        }
        body.dark-mode .code-artifact .artifact-content {
          background-color: rgba(30,30,30,0.8);  
        }
        .code-artifact .artifact-content pre { margin: 0; padding: 0; white-space: pre-wrap; word-break: break-all; }
        .code-artifact .artifact-content code { display: block; }

        .table-artifact .artifact-content { overflow-x: auto; }
        .table-artifact table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
            font-size: 0.9em;  
        }
        .table-artifact th, .table-artifact td {
            border: 1px solid var(--artifact-border-light); 
            padding: 5px 7px;  
            text-align: left;
            line-height: 1.3; 
            vertical-align: top;
            color: var(--text-color); font-weight: 500;
        }
        body.dark-mode .table-artifact th, body.dark-mode .table-artifact td {
            border-color: var(--artifact-border-dark);
        }
        .table-artifact th {
            background-color: rgba(0,0,0,0.035);  
            font-weight: 700; 
        }
        body.dark-mode .table-artifact th {
             background-color: rgba(255,255,255,0.05); 
        }


        .thinking-loader { display: flex; align-items: center; justify-content: center; padding: 8px 0; } 
        .thinking-loader div {
            width: 7.5px; height: 7.5px; margin: 0 2.8px; background-color: var(--secondary-text-color); 
            border-radius: 100%; display: inline-block; animation: sk-bouncedelay 1.4s infinite ease-in-out both;
            transition: background-color 0.3s;
        }
        .thinking-loader .bounce1 { animation-delay: -0.32s; } .thinking-loader .bounce2 { animation-delay: -0.16s; } .thinking-loader .bounce3 { animation-delay: 0s; }
        @keyframes sk-bouncedelay { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        
        .typing-cursor {
            display: inline-block;
            width: 1.5px;  
            height: 1.1em;  
            background-color: currentColor;
            animation: blink-cursor 1s step-end infinite;
            margin-left: 1px;
            vertical-align: text-bottom;
            opacity: 1; 
        }
        @keyframes blink-cursor { 
            from, to { background-color: transparent; } 
            50% { background-color: currentColor; } 
        }

        #input-area-wrapper {
            position: fixed;
            bottom: 15px;
            left: 20px;
            right: 20px;
            width: calc(100% - 40px);
            max-width: 800px;
            margin: 0 auto;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border-color);
            border-radius: 24px;
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            box-shadow: var(--glass-shadow);
            z-index: 100;
            padding: 9px 13px;
            display: flex;
            flex-direction: column;
            transition: padding 0.3s ease-out, background-color 0.3s ease-out, border 0.3s ease-out, box-shadow 0.3s ease-out, border-radius 0.3s ease-out, transform 0.5s ease-out, opacity 0.5s ease-out, backdrop-filter 0.3s;
            opacity: 0;
            transform: translateY(20px);
            overflow: visible; /* Allow menu to overflow */
        }
        #input-area-wrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: -80%;
            width: 60%;
            height: 100%;
            background: var(--glass-sheen);
            transform: skewX(-25deg);
            pointer-events: none;
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        #input-area-wrapper.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* NEW: Styles for collapsed input area */
        #input-area-wrapper.input-collapsed {
            opacity: 0 !important;
            pointer-events: none;
            transform: translateY(100%) scale(0.8);
            transition: transform 0.4s ease-in, opacity 0.4s ease-in;
        }

        #expand-input-area-btn {
            position: fixed;
            bottom: 15px;
            left: 20px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            box-shadow: 0 3px 10px rgba(0,0,0,0.15);
            color: var(--text-color);
            display: none; /* Initially hidden */
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 101;
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.3s, transform 0.3s;
        }

        #expand-input-area-btn.visible {
            display: flex;
            opacity: 1;
            transform: scale(1);
        }

        #expand-input-area-btn i {
            font-size: 20px;
        }

        #edit-mode-indicator-bar {
            display: none;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            margin-bottom: 8px;
            background-color: var(--edit-bar-bg-light);
            border: 1px solid var(--edit-bar-border-light);
            border-radius: 6px;
            font-size: 0.85em;
            color: var(--text-color);
            font-weight: 600;
        }
        body.dark-mode #edit-mode-indicator-bar {
            background-color: var(--edit-bar-bg-dark);
            border-color: var(--edit-bar-border-dark);
        }
        #cancel-edit-btn {
            background: transparent;
            border: none;
            padding: 0;
            cursor: pointer;
            color: var(--secondary-text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
        }
        #cancel-edit-btn i {
            font-size: 20px;
        }
        #cancel-edit-btn:hover {
            color: var(--text-color);
        }

        #attachment-preview-area {
            display: none; 
            margin-bottom: 8px; 
            max-width: 100%;
            overflow-x: auto; 
            overflow-y: hidden;
            padding-bottom: 8px;  
            scrollbar-width: thin; 
            scrollbar-color: transparent transparent; 
        }
        #attachment-preview-area::-webkit-scrollbar {
            height: 5px;  
            width: 5px;  
        }
        #attachment-preview-area::-webkit-scrollbar-track {
            background: transparent; 
        }
        #attachment-preview-area::-webkit-scrollbar-thumb {
            background: transparent; 
            border: none; 
        }

        #attachment-preview-content {
            display: flex; 
            gap: 8px;  
            align-items: flex-start; 
        }
        .attachment-preview-entry { 
            width: 70px;  
            height: 70px; 
            border-radius: 7px; 
            overflow: hidden; 
            border: 1px solid var(--border-color);
            background-color: var(--input-bg-color);
            position: relative; 
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; 
        }
         .attachment-preview-entry img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .attachment-preview-entry .file-icon-preview i { 
          margin-top: 10px;
          justify-content: center;
          align-items: center;
            font-size: 24px;  
            color: var(--icon-fill-color);
        }
        .attachment-preview-remove-btn {
            position: absolute;
            top: 2px;  
            right: 2px; 
            background-color: rgba(0,0,0,0.55); 
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px; 
            height: 20px; 
            font-size: 12px; 
            line-height: 20px;  
            text-align: center;
            cursor: pointer;
            box-shadow: 0 1px 1.5px rgba(0,0,0,0.18); 
            z-index: 1;
            opacity: 0.75; 
            transition: opacity 0.2s, background-color 0.2s;
            display: flex; 
            align-items: center; 
            justify-content: center; 
        }
        .attachment-preview-remove-btn:hover {
            opacity: 1;
            background-color: var(--stop-button-bg-color);
        }


        #remove-attachment-btn { display:none; } 

        #input-elements-container {
            display: flex;
            flex-direction: column;
            gap: 8px; 
            transition: opacity 0.3s ease-out, max-height 0.3s ease-out, visibility 0s linear 0.3s;
            opacity: 1;
            max-height: 480px;  
            overflow: visible;
            visibility: visible;
            padding-bottom: 3px; 
        }
        #input-area-wrapper.input-closed #input-elements-container {
             opacity: 0;
             max-height: 0;
             visibility: hidden;
             transition-delay: 0s, 0s, 0.3s;
             padding-bottom: 0;
        }

        .userInput-row {
            width: 100%;
            background-color: transparent; /* Diubah agar menyatu dengan container */
            border-radius: 16px;
            padding: 0 13px;
        }
        #userInput {
          width: 100%;
          padding: 9px 0;
          border: none; 
          background-color: transparent; 
          color: var(--input-text-color); 
          font-size: 0.95rem; font-family: var(--font-primary); 
          font-weight: 500;
          outline: none; resize: none; 
          max-height: 160px; 
          overflow-y: auto; line-height: 1.4; 
          scrollbar-width: none; -ms-overflow-style: none;
          transition: color 0.3s, height 0.2s ease-out; 
        }
        #userInput::-webkit-scrollbar { width: 0; height: 0; }
        #userInput::placeholder {
            color: var(--secondary-text-color); 
            opacity: 0.75; 
            font-weight: 500; 
        }


        #input-actions-row {
          display: flex; 
          align-items: center; 
          gap: 8px; 
          position: relative;
          width: 100%;
          justify-content: space-between; 
        }
        .input-actions-group-left, .input-actions-group-right {
            display: flex;
            align-items: center;
            gap: 8px; 
        }


        .input-area-btn {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border-color);
            box-shadow: var(--glass-shadow);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            color: var(--text-color);
            padding: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 12px; /* Rounded square shape */
            transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s, backdrop-filter 0.2s;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }
        .input-area-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -80%;
            width: 60%;
            height: 100%;
            background: var(--glass-sheen);
            transform: skewX(-25deg);
            pointer-events: none;
            opacity: 0.8;
        }
        .input-area-btn:hover:not(:disabled) {
            background-color: var(--glass-icon-button-hover-bg);
            border-color: var(--text-color);
        }
        .input-area-btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed !important; 
            background: var(--glass-bg) !important; 
            border-color: var(--glass-border-color) !important;
            color: var(--secondary-text-color) !important;
        }
        .input-area-btn i {
            color: currentColor;
            font-size: 19px; 
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1; 
        }
        
        /* NEW: Style for collapse button */
        #collapse-input-area-btn {
            position: absolute;
            left: 5px;
            bottom: 5px;
            border: none;
            background-color: transparent;
            width: 32px;
            height: 32px;
        }
        #collapse-input-area-btn:hover {
            background-color: var(--solid-hover-light);
        }
        body.dark-mode #collapse-input-area-btn:hover {
            background-color: var(--solid-hover-dark);
        }
        #collapse-input-area-btn i {
            font-size: 16px;
        }


        #file-actions-btn-container {
            position: relative;
            z-index: 10;
        }
        #file-actions-menu {
            display: none;
            position: absolute;
            bottom: calc(100% + 8px);
            left: 0;
            background-color: var(--surface-color); /* Solid background */
            border: 1px solid var(--border-color); /* Standard border */
            border-radius: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); /* Standard shadow */
            padding: 6px;
            z-index: 105;
            width: max-content;
            transition: background-color 0.3s, box-shadow 0.3s, border-color 0.3s;
        }
        #file-actions-menu button {
            display: block; width: 100%; padding: 8px 10px; 
            background: none; border: none; text-align: left;
            cursor: pointer; font-size: 0.85em; font-weight: 600;  color: var(--text-color); 
            border-radius: 8px; transition: background-color 0.2s, color 0.2s; 
            box-sizing: border-box;
        }
        #file-actions-menu button:hover {
            background-color: #27272a; /* Solid hover */
        }
        #file-actions-menu button:not(:last-child) { margin-bottom: 3px; } 
        #file-actions-menu button.active-option {
            font-weight: 700; 
            background-color: #27272a; /* Solid hover */
        }


        #model-switcher-container { display: none; }


        #deepthink-btn-container {
            position: relative;
            z-index: 10;
        }
        #deepthink-btn.active {
            color: var(--deepthink-active-color); background-color: var(--deepthink-active-bg);
            border-color: var(--deepthink-active-color);
            box-shadow: 0 0 0 1.5px var(--deepthink-active-color), 0 1px 2px rgba(0,0,0,0.1);
            z-index: 2;
        }
        #imageai-pollinations-model-menu { display: none; }


        #mic-btn {
            color: var(--mic-button-color);
        }
        #mic-btn.active {
            color: var(--mic-button-active-color);
            border-color: var(--mic-button-active-color);
            box-shadow: 0 0 0 1.5px var(--mic-button-active-color), 0 1px 2px rgba(0,0,0,0.1);
        }


        #sendBtn {
            padding: 0;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border-color);
            box-shadow: var(--glass-shadow);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            color: var(--text-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            flex-shrink: 0;
            border-radius: 12px; /* Rounded square shape */
            transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s, backdrop-filter 0.2s, color 0.2s;
            position: relative;
            overflow: hidden;
        }
        #sendBtn i {
            font-size: 18px;
            color: currentColor;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        #sendBtn:hover:not(:disabled) {
            background-color: var(--glass-icon-button-hover-bg);
            border-color: var(--text-color);
        }
        #sendBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed !important;
            background: var(--glass-bg) !important;
            border-color: var(--glass-border-color) !important;
            color: var(--secondary-text-color) !important;
            box-shadow: var(--glass-shadow) !important;
        }
        #sendBtn.stop-mode {
            background-color: var(--stop-button-bg-color);
            border-color: var(--stop-button-bg-color);
            color: var(--button-text-color);
        }
        #sendBtn.stop-mode:hover:not(:disabled) {
            background-color: var(--stop-button-hover-bg-color);
        }

        #voice-timer-display {
            display: none; 
            flex-grow: 1; 
            text-align: center; 
            align-self: center; 
            color: var(--secondary-text-color); 
            font-size: 0.9em; font-weight: 600;  
            font-variant-numeric: tabular-nums;
            margin: 0 4px;  
            min-width: 55px;  
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #voice-input-overlay-ui { display: none !important; } 

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--dialog-overlay-bg); display: flex; align-items: center; justify-content: center;
            z-index: 2000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s ease 0.3s, background-color 0.3s;
            padding: var(--safe-area-inset-top) var(--safe-area-inset-right) var(--safe-area-inset-bottom) var(--safe-area-inset-left);
        }
        .modal-overlay.visible { opacity: 1; visibility: visible; transition: opacity 0.3s ease, visibility 0s linear 0s;} 
        .modal-content {
            background-color: var(--solid-surface-light);
            padding: 0; 
            border-radius: 7px; 
            width: 88%; max-width: 480px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.12); 
            position: relative; 
            display: flex; flex-direction: column;
            max-height: calc(100vh - var(--safe-area-inset-top) - var(--safe-area-inset-bottom) - 35px); 
            transition: background-color 0.3s, box-shadow 0.3s, color 0.3s, border-color 0.3s;
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }
        body.dark-mode .modal-content {
            background-color: var(--solid-surface-dark);
            box-shadow: 0 4px 12px rgba(0,0,0,0.28); 
        }

        #camera-modal .modal-content {
            background-color: var(--surface-color); /* Solid background */
            border: 1px solid var(--border-color); /* Standard border */
        }
        .modal-header {
            padding: 13px 22px; 
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            background-color: var(--modal-header-bg);
            border-top-left-radius: 7px; 
            border-top-right-radius: 7px; 
        }
        .modal-header h2 { margin: 0; font-size: 1.25em; font-weight: 700;  color: var(--text-color); transition: color 0.3s; flex-grow: 1;} 
        .modal-header .modal-close-btn {
            font-size: 1.8em; font-weight: bold; cursor: pointer; color: var(--secondary-text-color); 
            transition: color 0.2s; background: none; border: none; padding: 0 4px; line-height: 1; 
            flex-shrink: 0; margin-left:12px; 
        }
        
#profile-modal .modal-close-btn {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background-color: var(--modal-header-bg); /* Memberi warna dasar agar bayangan terlihat */
    border: 1px solid var(--border-color); /* Garis tepi tipis agar lebih jelas */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.12); /* Bayangan untuk efek terangkat */
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    margin-left: 0;
    transition: background-color 0.2s, box-shadow 0.2s, transform 0.2s ease; /* Transisi halus */
}

body.dark-mode #profile-modal .modal-close-btn {
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25); /* Bayangan lebih kuat untuk mode gelap */
}

#profile-modal .modal-close-btn:hover {
    background-color: var(--solid-hover-light);
    transform: translateY(-2px); /* Tombol terangkat saat kursor di atasnya */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); /* Bayangan lebih besar saat terangkat */
}

body.dark-mode #profile-modal .modal-close-btn:hover {
    background-color: var(--solid-hover-dark);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}

#profile-modal .modal-close-btn:active {
    transform: translateY(0px); /* Tombol kembali ke posisi semula saat diklik */
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); /* Bayangan mengecil, efek ditekan */
    transition: transform 0.1s, box-shadow 0.1s; /* Transisi lebih cepat untuk klik */
}

        .modal-header .modal-close-btn:hover { color: var(--text-color); }
        
        .modal-body {
            overflow-y: auto; padding: 20px 22px; 
            flex-grow: 1;
            color: var(--text-color); font-weight: 500; 
            font-size: 0.95rem; 
        }
        .modal-body::-webkit-scrollbar { width: 6px; } 
        .modal-body::-webkit-scrollbar-track { background: var(--scrollbar-track-color); }
        .modal-body::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb-color); border-radius: 4px; }
        
        .modal-footer {
            padding: 13px 22px; 
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 10px; 
            flex-shrink: 0;
        }
        .modal-content button:not(.modal-close-btn):not(.modal-header-action-btn),
        .modal-footer button {
            padding: 9px 16px; border: none; border-radius: 5px; font-size: 0.9em; font-weight: 600;  cursor: pointer; 
            transition: background-color 0.2s, opacity 0.2s, color 0.2s; font-family: var(--font-primary);
            width: auto; margin-bottom: 0px;
            box-shadow: 0 1px 1.5px rgba(0,0,0,0.08); 
        }
         .modal-content button:disabled:not(.modal-close-btn) { opacity: 0.6; cursor: not-allowed; }

        .modal-file-input-label {
            display: block; width: 100%; padding: 9px 16px; cursor: pointer; 
            border: 1px solid var(--border-color); border-radius: 5px; background-color: var(--input-bg-color); margin-bottom: 8px; 
            text-align: center; font-size: 0.9em; font-weight: 600;  color: var(--text-color); 
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }
        .modal-file-input-label:hover { background-color: var(--model-switcher-hover-bg); }
        .modal-hidden-file-input { display: none; }
        .modal-selected-filename {
            font-size: 0.8em; color: var(--secondary-text-color); margin-top: -4px; margin-bottom: 12px; 
            word-break: break-all; text-align: center; padding: 0 4px; font-weight: 600; transition: color 0.3s; 
        }
        .modal-textarea-result {
            width: 100%; font-family: var(--font-primary); font-size: 0.9em; padding: 8px 11px; 
            border: 1px solid var(--border-color); border-radius: 5px; background-color: var(--input-bg-color); 
            color: var(--input-text-color); resize: vertical; min-height: 80px; margin-bottom: 12px; 
            font-weight: 500; 
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        
        /* ========================================================== */
        /* PERUBAHAN ARTIFACT VIEWER MENJADI BOTTOM SHEET MODAL        */
        /* ========================================================== */
        #artifact-viewer-modal {
            align-items: flex-end; /* Align content to bottom */
            padding: 0;
        }
        
        #artifact-viewer-modal .modal-content {
            width: 100%;
            height: 90vh;
            max-height: 90vh;
            border-radius: 16px 16px 0 0; /* Rounded top corners */
            box-shadow: 0 -5px 25px rgba(0,0,0,0.15);
            border: 1px solid var(--border-color);
            border-bottom: none;
            transform: translateY(100%); /* Start off-screen */
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #artifact-viewer-modal.visible .modal-content {
            transform: translateY(0); /* Slide in */
        }
        
        body.dark-mode #artifact-viewer-modal .modal-content {
            box-shadow: 0 -5px 25px rgba(0,0,0,0.3);
        }

        /* New Grabber Handle */
        .modal-grabber {
            width: 40px;
            height: 5px;
            background-color: var(--border-color);
            border-radius: 2.5px;
            margin: 8px auto; /* Centered handle */
            flex-shrink: 0;
        }

        #artifact-viewer-modal .modal-header {
            background-color: var(--modal-header-bg);
            padding: 8px calc(15px + var(--safe-area-inset-right)) 8px calc(15px + var(--safe-area-inset-left));
            border-bottom: 1px solid var(--border-color);
            border-radius: 0; /* Header doesn't need radius now */
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        #artifact-viewer-modal .modal-header-title-buttons-group {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-grow: 1; /* Allow title to take space */
            overflow: hidden; /* Prevent title from pushing buttons out */
        }

        #artifact-viewer-modal .artifact-viewer-html-controls {
            display: none !important;
        }

        #artifact-viewer-modal .modal-header h2#artifact-viewer-title {
            font-size: 1.1em;
            font-weight: 700;
            color: var(--text-color);
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: none; /* Let flexbox handle it */
        }

        #artifact-viewer-modal .modal-close-btn { /* This is the (X) button */
            font-size: 1.8em;
            color: var(--secondary-text-color);
            background: none; border: none; padding: 0;
            line-height: 1;
            cursor: pointer;
            width: 32px; height: 32px;
            display: flex; align-items: center; justify-content: center;
            flex-shrink: 0; /* Prevent shrinking */
        }
        #artifact-viewer-modal .modal-close-btn:hover { color: var(--text-color); }
        
        .modal-actions-bar {
            padding: 0;
            display: flex;
            gap: 12px;
            align-items: center;
            margin-left: auto; /* Push to the right */
            padding-right: 12px; /* Space before close button */
            flex-shrink: 0; /* Prevent shrinking */
        }

        .modal-actions-bar .modal-header-action-btn {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            padding: 5px !important;
            width: 28px !important;
            height: 28px !important;
            color: var(--secondary-text-color) !important;
            cursor: pointer;
            transition: color 0.2s, background-color 0.2s;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-actions-bar .modal-header-action-btn:hover {
             color: var(--text-color) !important;
             background-color: var(--solid-hover-light) !important;
        }
        body.dark-mode .modal-actions-bar .modal-header-action-btn:hover {
             background-color: var(--solid-hover-dark) !important;
        }
        .modal-actions-bar .modal-header-action-btn i {
            font-size: 19px;
            color: currentColor;
        }

        #artifact-viewer-modal-body {
            font-size: 0.9em;
            line-height: 1.5;
            flex-grow: 1;
            overflow: hidden; /* Let child scroll */
            color: var(--text-color);
            padding: 0; /* Removed padding */
            font-weight: 500;
            background-color: var(--surface-color);
            display: flex; /* Make it a flex container */
            flex-direction: column; /* Stack children vertically */
            min-height: 0; /* Crucial for flex scrolling */
            padding-bottom: var(--safe-area-inset-bottom);
        }
        
        #artifact-viewer-modal-body > * {
            flex-grow: 1; /* Make the content div grow */
            overflow: auto; /* The content div is now the scroller */
            padding: 15px; /* Add padding here */
            padding-left: calc(15px + var(--safe-area-inset-left));
            padding-right: calc(15px + var(--safe-area-inset-right));
        }

        #artifact-viewer-modal-body::-webkit-scrollbar { width: 8px; height: 8px; } 
        #artifact-viewer-modal-body::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); }
        body.dark-mode #artifact-viewer-modal-body::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
        #artifact-viewer-modal-body::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb-color); border-radius: 10px; }
        #artifact-viewer-modal-body { scrollbar-width: thin; scrollbar-color: var(--scrollbar-thumb-color) rgba(0,0,0,0.05); }
        body.dark-mode #artifact-viewer-modal-body { scrollbar-color: var(--scrollbar-thumb-color) rgba(255,255,255,0.05); }
        
        #artifact-viewer-modal-body iframe#artifact-html-preview-iframe {
            display: none !important;
        }

        #artifact-viewer-modal-body pre {
            white-space: pre-wrap;
            word-break: break-all;
            margin: 0;
        }
        #artifact-viewer-modal-body .code-artifact-viewer-content {
            background-color: var(--input-bg-color); 
            color: var(--input-text-color); 
            font-family: 'Courier New', Courier, monospace; 
            border-radius: 5px; 
        }
        body.dark-mode #artifact-viewer-modal-body .code-artifact-viewer-content {
            background-color: #1e1e1e;
            color: #d4d4d4;
        }
        #artifact-viewer-modal-body .table-artifact-viewer-content { 
             /* No specific styles needed, default table will work */
        }
        #artifact-viewer-modal-body table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
            font-size: 0.95em;  
        }
        #artifact-viewer-modal-body th, #artifact-viewer-modal-body td {
            border: 1px solid var(--border-color);
            padding: 6px 8px;  
            text-align: left;
            vertical-align: top;
            color: var(--text-color); font-weight: 500;
        }
        #artifact-viewer-modal-body th {
            background-color: var(--input-bg-color);
            font-weight: 700; 
        }
        
        .fullscreen-modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--bg-color);
            z-index: 2500; opacity: 0; visibility: hidden; 
            transition: opacity 0.3s ease, visibility 0s ease 0.3s;
            display: flex; flex-direction: column;
        }
        .fullscreen-modal-overlay.visible {
            opacity: 1; visibility: visible; transition-delay: 0s;
        }
        .fullscreen-modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 calc(12px + var(--safe-area-inset-right)) 0 calc(12px + var(--safe-area-inset-left));
            height: calc(var(--header-height) + var(--safe-area-inset-top));
            padding-top: var(--safe-area-inset-top);
            flex-shrink: 0;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--surface-color);
        }
        .fullscreen-modal-header .logo-title-group {
            display: flex; align-items: center; gap: 10px;
        }
        .fullscreen-modal-header .logo-title-group img {
            height: 32px; width: 32px; border-radius: 50%;
        }
        .fullscreen-modal-header .logo-title-group h2 {
            margin: 0; font-size: 1.1em; font-weight: 700; color: var(--text-color);
        }
        .fullscreen-modal-header .modal-close-btn {
            font-size: 1.8em; color: var(--secondary-text-color);
            background: none; border: none; padding: 0 4px; line-height: 1;
            cursor: pointer; transition: color 0.2s;
        }
        .fullscreen-modal-header .modal-close-btn:hover { color: var(--text-color); }

        .fullscreen-modal-body {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            color: var(--text-color);
            padding-left: calc(20px + var(--safe-area-inset-left));
            padding-right: calc(20px + var(--safe-area-inset-right));
            padding-bottom: calc(20px + var(--safe-area-inset-bottom));
        }
        .fullscreen-modal-body::-webkit-scrollbar {
            display: none;
        }
        .fullscreen-modal-body {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        .fullscreen-modal-body h3 {
            font-size: 1.2em; font-weight: 600; margin-top: 1.5em; margin-bottom: 0.8em;
            border-bottom: 1px solid var(--border-color); padding-bottom: 5px;
        }
        .fullscreen-modal-body h3:first-child { margin-top: 0; }
        .fullscreen-modal-body p, .fullscreen-modal-body li {
            line-height: 1.7; font-size: 0.95em; font-weight: 500;
        }
        .fullscreen-modal-body .copyright-footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            font-size: 0.85em;
            color: var(--secondary-text-color);
        }

        #report-form .form-group {
            margin-bottom: 15px;
        }
        #report-form label {
            display: block;
            font-weight: 600;
            margin-bottom: 6px;
            font-size: 0.9em;
        }
        #report-form input[type="text"],
        #report-form input[type="email"],
        #report-form textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: var(--input-bg-color);
            color: var(--input-text-color);
            font-size: 0.95em;
            font-family: var(--font-primary);
        }
        
        #report-form #report-category {
            display: none; /* Hide original select */
        }
        .custom-select-container {
            position: relative;
            width: 100%;
            font-size: 0.95em;
            font-family: var(--font-primary);
        }
        .custom-select-trigger {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: var(--input-bg-color);
            color: var(--input-text-color);
            text-align: left;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: border-color 0.2s, background-color 0.2s;
        }
        .custom-select-trigger::after {
            content: '';
            border: solid currentColor;
            border-width: 0 2px 2px 0;
            display: inline-block;
            padding: 3px;
            transform: rotate(45deg);
            -webkit-transform: rotate(45deg);
            transition: transform 0.2s;
        }
        .custom-select-container.open .custom-select-trigger {
            border-color: var(--button-bg-color);
        }
        .custom-select-container.open .custom-select-trigger::after {
            transform: rotate(-135deg);
            -webkit-transform: rotate(-135deg);
        }
        .custom-select-options {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: var(--surface-color); /* Solid background */
            border: 1px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 5px 5px;
            z-index: 10;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .custom-select-container.open .custom-select-options {
            display: block;
        }
        .custom-select-option {
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .custom-select-option:hover, .custom-select-option.selected {
            background-color: var(--solid-hover-light);
        }
        body.dark-mode .custom-select-option:hover, 
        body.dark-mode .custom-select-option.selected {
            background-color: var(--solid-hover-dark);
        }
        .custom-select-option[data-value=""] {
            color: var(--secondary-text-color);
            font-style: italic;
        }
        .custom-select-options::-webkit-scrollbar {
            display: none;
        }
        .custom-select-options {
            -ms-overflow-style: none; /* IE and Edge */
            scrollbar-width: none;    /* Firefox */
        }

        #report-form textarea {
            min-height: 120px;
            resize: vertical;
        }
        #report-form #report-submit-btn {
            width: 100%;
            padding: 12px;
            background-color: #6c757d;
            color: var(--button-text-color);
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #report-form #report-submit-btn:hover {
            background-color: #5a6268;
        }

        #report-attachment-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
            padding: 4px 0;
        }
        .report-preview-entry {
            width: 70px;
            height: 70px;
            border-radius: 7px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg-color);
            position: relative;
            flex-shrink: 0;
            aspect-ratio: 1 / 1;
        }
        .report-preview-entry img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .report-preview-remove-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            background-color: rgba(0,0,0,0.55);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            line-height: 20px;
            text-align: center;
            cursor: pointer;
            box-shadow: 0 1px 1.5px rgba(0,0,0,0.18);
            z-index: 1;
            opacity: 0.75;
            transition: opacity 0.2s, background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .report-preview-remove-btn:hover {
            opacity: 1;
            background-color: var(--stop-button-bg-color);
        }

        .custom-dialog-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--dialog-overlay-bg);
            display: flex; align-items: center; justify-content: center;
            z-index: 4000;
            opacity: 0; visibility: hidden;
            transition: opacity 0.2s ease-out, visibility 0s linear 0.2s, background-color 0.3s;
            padding: 18px; 
        }
        .custom-dialog-overlay.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
        .custom-dialog {
            background-color: var(--solid-surface-light);
            padding: 24px; border-radius: 10px; 
            width: 100%; max-width: 380px; 
            box-shadow: 0 7px 22px rgba(0,0,0,0.09); 
            text-align: center;
            transform: scale(0.95); opacity: 0;
            transition: transform 0.2s ease-out, opacity 0.2s ease-out, background-color 0.3s, box-shadow 0.3s, color 0.3s, border-color 0.3s;
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }
        body.dark-mode .custom-dialog {
            background-color: var(--solid-surface-dark);
            box-shadow: 0 7px 22px rgba(0,0,0,0.22); 
        }
        .custom-dialog-overlay.visible .custom-dialog { transform: scale(1); opacity: 1; }
        .custom-dialog h3 {
            font-size: 1.25em; color: var(--text-color); 
            margin-top: 0; margin-bottom: 13px; font-weight: 700;  transition: color 0.3s; 
        }
        .custom-dialog p {
            font-size: 0.95em; color: var(--secondary-text-color); 
            line-height: 1.6; margin-bottom: 24px; font-weight: 500;  transition: color 0.3s; 
        }
        .custom-dialog-actions { display: flex; justify-content: center; gap: 12px; } 
        .custom-dialog-actions button {
            padding: 9px 20px; border: none; border-radius: 7px; 
            font-size: 0.9em; font-weight: 600;  cursor: pointer; 
            transition: background-color 0.2s, opacity 0.2s, color 0.2s;
            min-width: 95px; 
        }
        .custom-dialog-actions button.primary { background-color: var(--dialog-button-primary-bg); color: var(--button-text-color); }
        .custom-dialog-actions button.primary:hover { background-color: #166ee5; }
        body.dark-mode .custom-dialog-actions button.primary:hover { background-color: #267feb; }
        .custom-dialog-actions button.secondary { background-color: var(--dialog-button-secondary-bg); color: var(--button-text-color); }
        .custom-dialog-actions button.secondary:hover { background-color: #5a6268; }
        .custom-dialog-actions button.danger { background-color: var(--dialog-button-danger-bg); color: var(--button-text-color); }
        .custom-dialog-actions button.danger:hover { background-color: var(--stop-button-hover-bg-color); }

        #profile-modal {
            align-items: center; 
        }
        #profile-modal .modal-content {
            max-width: 420px;
            border-radius: 12px;
            padding: 0;
            background-color: var(--surface-color); /* Explicitly set solid background */
        }
        #profile-modal .modal-header {
            padding: 10px 15px;
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
        }
        #profile-modal .modal-header h2 {
            font-size: 1.1em;
        }
        #profile-modal .modal-body {
            padding: 0;
        }
        .profile-info-header {
            display: flex;
            align-items: center;
            padding: 20px;
            gap: 20px;
        }
        .profile-info-avatar img {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
        }
        .profile-info-stats {
            display: flex;
            gap: 20px;
            text-align: center;
            flex-grow: 1;
            justify-content: space-around;
        }
        .profile-stat {
            font-size: 0.9em;
        }
        .profile-stat-number {
            font-size: 1.1em;
            font-weight: 700;
            display: block;
        }
        .profile-stat-label {
            color: var(--secondary-text-color);
            font-size: 0.8em;
        }

        .profile-details {
            padding: 0 20px 20px 20px;
        }
        .profile-details .name {
            font-weight: 700;
            font-size: 1.1em;
            margin: 0;
        }
        .profile-details .title {
            color: var(--secondary-text-color);
            font-size: 0.9em;
            margin: 2px 0 10px 0;
        }
        .profile-details .bio {
            font-size: 0.95em;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .profile-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        /* MODIFIED: Changed buttons to a tags for direct linking */
        .profile-actions a {
            flex-grow: 1;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid transparent;
            text-decoration: none;
            text-align: center;
            display: inline-block;
        }
        .profile-actions .follow-btn {
            background-color: var(--button-bg-color);
            color: var(--button-text-color);
            border-color: var(--button-bg-color);
        }
        .profile-actions .message-btn {
            background-color: var(--input-bg-color);
            color: var(--text-color);
            border-color: var(--border-color);
        }

        .profile-socials {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 15px;
            border-top: 1px solid var(--border-color);
        }
        .profile-socials a {
            color: var(--text-color);
            font-size: 24px;
            transition: transform 0.2s, color 0.2s;
        }
        .profile-socials a:hover {
            transform: scale(1.1);
            color: var(--button-bg-color);
        }
    </style>
</head>
<body>
    <div id="dot-grid-background"></div>
    <div id="bottom-vignette"></div>

    <div id="app-layout-container">
        <div id="app-header">
            <div id="profile-container">
                <div id="profile-pic-container">
                    <img src="https://s6.imgcdn.dev/YsWz8D.png" alt="Profile Picture">
                </div>
                <span id="profile-text">FlabsAI</span>
            </div>
            
            <div id="app-header-tools-container">
                <!-- PERBAIKAN: Tombol New Chat dengan Dropdown Konfirmasi -->
                <button id="new-chat-btn" class="header-control-btn" title="Pesan Baru">
                    <i class="fi fi-rr-refresh"></i>
                </button>
                <div id="new-chat-confirm-menu">
                    <!-- PERBAIKAN: Kelas diubah ke 'success' dan ikon dihapus -->
                    <button id="confirm-new-chat-btn" class="success">
                        <span>Mulai Chat Baru</span>
                    </button>
                </div>
                
                <button id="toggle-tools-dropdown-btn" class="header-control-btn" title="Alat">
                    <i class="fi fi-rr-settings"></i>
                </button>
                <div id="tools-dropdown-menu">
                    <button id="download-chat-btn" title="Unduh Riwayat Chat (JSON)">
                        <i class="fi fi-rr-download"></i>
                        <span class="tools-dropdown-text">Unduh Chat</span>
                    </button>
                     <button id="download-chat-pdf-btn" title="Unduh Riwayat Chat (PDF)" style="display:none;">
                        <i class="fi fi-rr-file-pdf"></i>
                        <span class="tools-dropdown-text">Unduh Chat</span>
                    </button>
                    <button id="import-chat-btn" title="Impor Riwayat (JSON)">
                        <i class="fi fi-rr-file-import"></i>
                        <span class="tools-dropdown-text">Impor Chat</span>
                    </button>
                    <button id="report-problem-btn" title="Laporkan Masalah">
                        <i class="fi fi-rr-comment-exclamation"></i>
                        <span class="tools-dropdown-text">Laporkan Masalah</span>
                    </button>
                    <button id="about-app-btn" title="Tentang Aplikasi">
                        <i class="fi fi-rr-info"></i>
                        <span class="tools-dropdown-text">Tentang</span>
                    </button>
                </div>
            </div>
        </div>
        
        <div id="main-logo-header">
            <h2>Ada Yang Bisa Saya Bantu?</h2>
        </div>

        <div id="quick-actions-carousel-wrapper" style="display: none;">
            <div id="quick-actions-title-container" style="display: none; opacity: 0;">
                <h2 id="quick-actions-title-text"></h2>
            </div>
            <div class="quick-actions-gallery-container">
                <!-- Action Cards will be generated by JavaScript -->
            </div>
        </div>
        <div class="quick-actions-carousel-dots-container" style="display: none !important;">
            <!-- Dots will be generated by JavaScript -->
        </div>
        <div id="quick-actions-swipe-hint" style="display: none !important;">&lt; swipe &gt;</div>


        <div id="chat-container"></div>
        
        <!-- NEW: Bottom fade overlay element -->
        <div id="bottom-fade-overlay"></div>

        <div id="input-area-wrapper">
            <div id="edit-mode-indicator-bar" style="display: none;">
                <span id="edit-mode-text">Mode Edit Pesan</span>
                <button id="cancel-edit-btn" title="Batalkan Edit"><i class="fi fi-rr-cross-small"></i></button>
            </div>
            <div id="attachment-preview-area">
                <div id="attachment-preview-content">
                    <!-- File previews will be dynamically added here -->
                </div>
            </div>
            <div id="input-elements-container">
                <div class="userInput-row">
                    <textarea id="userInput" placeholder="Ketik pesan atau minta buat gambar..." rows="1"></textarea>
                </div>
                <div id="input-actions-row">
                    <div class="input-actions-group-left" id="normal-actions-left">
                        <!-- NEW: Collapse button, now inside the left group -->
                       
                        <div id="file-actions-btn-container">
                            <button id="file-actions-btn" class="input-area-btn" title="Tambah Lampiran/Aksi">
                                <i class="fi fi-rr-plus"></i>
                            </button>
                            <div id="file-actions-menu">
                                <!-- Menu items will be set by JS -->
                            </div>
                        </div>
                    </div>
                    
                    <button id="voice-cancel-btn" class="input-area-btn" title="Batalkan Input Suara" style="display:none;">
                        <i class="fi fi-rr-cross-small"></i>
                    </button>
                    <div id="voice-timer-display" style="display:none;">0:00</div>
                     <button id="voice-stop-convert-btn" class="input-area-btn" title="Selesai Input Suara" style="display:none;">
                        <i class="fi fi-rr-check"></i>
                    </button>
                    
                    <input type="file" id="image-attachment-input" class="modal-hidden-file-input" accept="image/*" multiple>
                    <input type="file" id="document-attachment-input" class="modal-hidden-file-input" accept=".pdf,.js,.py,.txt,.html,.css,.md,.csv,.xml,.rtf,.java,.json,.xlsx,.xls" multiple>
                    <input type="file" id="import-chat-file-input" class="modal-hidden-file-input" accept=".json">

                    
                    <div class="input-actions-group-right" id="normal-actions-right">
                        <div id="deepthink-btn-container">
                            <button id="deepthink-btn" class="input-area-btn" title="Mode Berpikir Mendalam">
                                <i class="fi fi-rr-bulb"></i>
                            </button>
                        </div>
                        <button id="mic-btn" class="input-area-btn" title="Input Suara">
                            <i class="fi fi-rr-microphone"></i>
                        </button>
                        <button id="sendBtn" title="Kirim">
                             <i class="fi fi-rr-paper-plane"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- NEW: Expand Input Area button (initially hidden) -->
        <button id="expand-input-area-btn" title="Buka Area Input">
            <i class="fi fi-rr-angle-small-up"></i>
        </button>
        
    </div>

    <div id="profile-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Profil Kreator</h2>
                <button class="modal-close-btn" id="profile-modal-close-btn" aria-label="Tutup Profil"><i class="fi fi-rr-cross-small" style="font-size: 1.2em;"></i></button>
            </div>
            <div class="modal-body">
                <div class="profile-info-header">
                    <div class="profile-info-avatar">
                        <img src="https://s6.imgcdn.dev/YsemS0.jpg" alt="Foto Profil Fema Andara Haqi">
                    </div>
                    <div class="profile-info-stats">
                        <div class="profile-stat">
                            <span class="profile-stat-number">17</span>
                            <span class="profile-stat-label">Proyek</span>
                        </div>
                        <div class="profile-stat">
                            <span class="profile-stat-number">823</span>
                            <span class="profile-stat-label">Pengikut</span>
                        </div>
                        <div class="profile-stat">
                            <span class="profile-stat-number">71</span>
                            <span class="profile-stat-label">Mengikuti</span>
                        </div>
                    </div>
                </div>
                <div class="profile-details">
                    <p class="name">Fema Andara Haqi</p>
                    <p class="title">Software Engineer & AI Enthusiast</p>
                    <p class="bio">
                        Siswa berusia 16 tahun dengan passion di bidang rekayasa perangkat lunak dan kecerdasan buatan. Kreator di balik FlabsAI, dengan misi membuat teknologi canggih menjadi mudah diakses dan bermanfaat bagi semua orang.
                    </p>
                    <!-- MODIFIED: Buttons are now links -->
                    <div class="profile-actions">
                        <a href="https://instagram.com/femzlabs_" target="_blank" class="follow-btn">Ikuti</a>
                        <a href="https://instagram.com/femzlabs_" target="_blank" class="message-btn">Kirim Pesan</a>
                    </div>
                </div>
                <div class="profile-socials">
                    <a href="https://github.com/FemaHaqi" target="_blank" title="GitHub"><i class="fi fi-brands-github"></i></a>
                    <a href="https://www.instagram.com/fema.haqi_/" target="_blank" title="Instagram"><i class="fi fi-brands-instagram"></i></a>
                    <a href="https://www.linkedin.com/" target="_blank" title="LinkedIn"><i class="fi fi-brands-linkedin"></i></a>
                </div>
            </div>
        </div>
    </div>

    <!-- Artifact Viewer Modal (MODIFIED TO BE A BOTTOM SHEET) -->
    <div id="artifact-viewer-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-grabber"></div> <!-- GAGANG UNTUK GESER -->
            <div class="modal-header">
                <div class="modal-header-title-buttons-group">
                     <h2 id="artifact-viewer-title">Lihat Artifact</h2>
                </div>
                <div class="modal-actions-bar">
                    <button id="artifact-viewer-copy-btn" class="modal-header-action-btn" title="Salin Konten">
                        <i class="fi fi-rr-copy-alt"></i>
                    </button>
                    <button id="artifact-viewer-download-btn" class="modal-header-action-btn" title="Unduh Artifact">
                        <i class="fi fi-rr-download"></i>
                    </button>
                </div>
                <button class="modal-close-btn" id="artifact-viewer-close-btn" aria-label="Tutup Pelihat Artifact">
                    <i class="fi fi-rr-cross-small"></i>
                </button>
            </div>
            <div class="modal-body" id="artifact-viewer-modal-body">
                <!-- Content will be injected by JS. -->
            </div>
        </div>
    </div>


    <!-- About App Modal (New) -->
    <div id="about-modal" class="fullscreen-modal-overlay">
        <div class="fullscreen-modal-header">
            <div class="logo-title-group">
                <img src="https://s6.imgcdn.dev/YsWz8D.png" alt="FlabsAI Logo">
                <h2>Tentang FlabsAI</h2>
            </div>
            <button class="modal-close-btn" id="about-modal-close-btn" aria-label="Tutup Tentang Aplikasi">
                <i class="fi fi-rr-cross-small" style="font-size: 1.2em;"></i>
            </button>
        </div>
        <div class="fullscreen-modal-body">
            <h3>Selamat Datang di FlabsAI</h3>
            <p>FlabsAI adalah sebuah platform kecerdasan buatan (AI) serbaguna yang dirancang dan dikembangkan oleh <strong>Fema Andara Haqi</strong>, seorang siswa berbakat berusia 16 tahun. Aplikasi ini merupakan perwujudan dari semangat inovasi dan keingintahuan dalam dunia teknologi, dengan tujuan untuk menyediakan asisten AI yang tidak hanya cerdas, tetapi juga adaptif, kreatif, dan mudah diakses oleh semua orang.</p>
            
            <h3>Misi & Visi</h3>
            <p>Misi kami adalah mendemokratisasi akses terhadap teknologi AI canggih. Kami percaya bahwa setiap orang berhak mendapatkan manfaat dari kemajuan AI, baik untuk membantu pekerjaan sehari-hari, memicu kreativitas, atau sekadar menjadi teman diskusi yang cerdas. Visi FlabsAI adalah menjadi platform AI percakapan terdepan yang intuitif, imersif, dan selalu berevolusi mengikuti kebutuhan penggunanya.</p>
            
            <h3>Fitur Unggulan</h3>
            <ul>
                <li><strong>Percakapan Dinamis:</strong> Didukung oleh model AI Gemini terbaru dari Google, FlabsAI mampu memahami konteks, menjawab pertanyaan kompleks, dan beradaptasi dengan berbagai peran yang Anda berikan.</li>
                <li><strong>Kreasi Gambar (ImageAI):</strong> Ubah imajinasi Anda menjadi gambar visual. Cukup berikan deskripsi (prompt), dan AI akan menghasilkan gambar unik untuk Anda.</li>
                <li><strong>Analisis File & Gambar:</strong> Unggah gambar atau dokumen (seperti PDF, TXT, file kode) untuk dianalisis. FlabsAI dapat meringkas, menjelaskan, atau menjawab pertanyaan berdasarkan konten yang Anda berikan.</li>
                <li><strong>Mode Berpikir Mendalam (DeepThink):</strong> Butuh jawaban yang lebih komprehensif? Aktifkan mode DeepThink untuk mendapatkan analisis yang lebih mendalam, perspektif yang lebih luas, dan jawaban yang lebih terstruktur.</li>
                <li><strong>Input Suara:</strong> Interaksi lebih mudah dan cepat dengan fitur input suara yang akurat untuk Bahasa Indonesia.</li>
                <li><strong>Kustomisasi & Kontrol:</strong> Unduh riwayat percakapan, impor sesi sebelumnya, dan pilih antara mode terang atau gelap untuk kenyamanan visual Anda.</li>
            </ul>

            <h3>Ketentuan Layanan Singkat</h3>
            <p>Dengan menggunakan FlabsAI, Anda setuju untuk tidak menggunakan layanan ini untuk tujuan ilegal, menyebarkan kebencian, pelecehan, atau membuat konten yang tidak pantas. FlabsAI berhak memblokir akses bagi pengguna yang melanggar ketentuan. Respons yang dihasilkan oleh AI mungkin tidak selalu 100% akurat; harap gunakan dengan bijak dan lakukan verifikasi untuk informasi penting.</p>

            <div class="copyright-footer">
                <p>&copy; 2025 FlabsAI. Semua Hak Cipta Dilindungi.</p>
            </div>
        </div>
    </div>

    <!-- Report Problem Modal (New) -->
    <div id="report-modal" class="fullscreen-modal-overlay">
        <div class="fullscreen-modal-header">
            <div class="logo-title-group">
                <img src="https://s6.imgcdn.dev/YsWz8D.png" alt="FlabsAI Logo">
                <h2>Laporkan Masalah</h2>
            </div>
            <button class="modal-close-btn" id="report-modal-close-btn" aria-label="Tutup Laporan Masalah">
                <i class="fi fi-rr-cross-small" style="font-size: 1.2em;"></i>
            </button>
        </div>
        <div class="fullscreen-modal-body">
            <form id="report-form">
                <div class="form-group">
                    <label for="report-name">Nama Lengkap Anda</label>
                    <input type="text" id="report-name" name="name" placeholder="Masukkan nama Anda" required>
                </div>
                <div class="form-group">
                    <label for="report-email">Alamat Email Anda</label>
                    <input type="email" id="report-email" name="email" placeholder="contoh@gmail.com" required>
                </div>
                <div class="form-group">
                    <label for="report-category">Kategori Masalah</label>
                    <select id="report-category" name="category" required>
                        <option value="">-- Pilih Kategori --</option>
                        <option value="Bug/Error Aplikasi">Bug/Error Aplikasi</option>
                        <option value="Respons AI Tidak Akurat">Respons AI Tidak Akurat</option>
                        <option value="Masalah Tampilan (UI/UX)">Masalah Tampilan (UI/UX)</option>
                        <option value="Saran Fitur">Saran Fitur</option>
                        <option value="Lainnya">Lainnya</option>
                    </select>
                    <div class="custom-select-container">
                        <div class="custom-select-trigger" tabindex="0">-- Pilih Kategori --</div>
                        <div class="custom-select-options"></div>
                    </div>
                </div>
                <div class="form-group">
                    <label for="report-attachment-input">Lampirkan Screenshot (Opsional)</label>
                     <label for="report-attachment-input" class="modal-file-input-label">Pilih Gambar...</label>
                    <input type="file" id="report-attachment-input" name="attachment" class="modal-hidden-file-input" accept="image/*" multiple>
                    <div id="report-attachment-preview"></div>
                </div>
                <div class="form-group">
                    <label for="report-description">Deskripsi Masalah</label>
                    <textarea id="report-description" name="description" placeholder="Jelaskan masalah yang Anda hadapi secara detail..." required></textarea>
                </div>
                <button type="submit" id="report-submit-btn">Kirim Laporan</button>
            </form>

            <div class="copyright-footer">
                <p>&copy; 2025 FlabsAI. Semua Hak Cipta Dilindungi.</p>
            </div>
        </div>
    </div>

    <div id="custom-dialog-overlay" class="custom-dialog-overlay">
        <div class="custom-dialog">
            <h3 id="custom-dialog-title">Pemberitahuan</h3>
            <p id="custom-dialog-message">Ini adalah pesan dialog.</p>
            <div class="custom-dialog-actions">
                <button id="custom-dialog-btn-confirm" class="primary">OK</button>
                <button id="custom-dialog-btn-cancel" class="secondary" style="display:none;">Batal</button>
            </div>
        </div>
    </div>

    <!-- NEW: User Message Context Menu (for long-press) -->
    <div id="user-message-context-menu" style="display: none;">
        <button id="user-context-copy-btn">
            <i class="fi fi-rr-copy-alt"></i>
            <span>Salin</span>
        </button>
        <button id="user-context-edit-btn">
            <i class="fi fi-rr-pencil"></i>
            <span>Edit</span>
        </button>
    </div>

    <!-- Camera Modal -->
    <div id="camera-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Ambil Foto</h2>
                <button class="modal-close-btn" id="camera-modal-close-btn">&times;</button>
            </div>
            <div class="modal-body" style="padding:0; position:relative;">
                <video id="camera-preview" autoplay playsinline style="width:100%; height:auto; display:block;"></video>
                <div id="camera-loading" style="position:absolute; top:0; left:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.5); color:white;">Membuka kamera...</div>
            </div>
            <div class="modal-footer" style="justify-content:center;">
                <button id="capture-photo-btn" class="input-area-btn" style="width:60px; height:60px; border-radius:50%;"><i class="fi fi-sr-camera" style="font-size:24px;"></i></button>
            </div>
        </div>
    </div>


    <script id="imageProcessorWorkerScript" type="javascript/worker">
        // --- Start of Embedded Worker Code (imageProcessorFlabs.js) ---
        // Helper Functions
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function gaussian(x, sigma) {
            return Math.exp(-(x * x) / (2 * sigma * sigma));
        }

        // SIMPLIFIED BILATERAL FILTER (Denoise)
        async function applySimplifiedBilateralFilter(imageData, spatialSigma, intensitySigma, progressCallback, baseProgress, stageWeight) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const newData = new Uint8ClampedArray(data.length);
            const kernelRadius = Math.ceil(spatialSigma * 2.5);
            let lastProgressUpdate = 0;

            for (let y = 0; y < height; y++) {
                const currentStepProgress = Math.round((y / height) * 100);
                // Removed detailed progress messages for denoising
                if (currentStepProgress > lastProgressUpdate || y === height - 1) {
                    if (progressCallback) progressCallback(baseProgress + (currentStepProgress * stageWeight) /*, `Denoising... ${currentStepProgress}%` REMOVED */);
                    await new Promise(resolve => setTimeout(resolve, 0)); 
                    lastProgressUpdate = currentStepProgress;
                }

                for (let x = 0; x < width; x++) {
                    let totalWeight = 0;
                    let sumR = 0, sumG = 0, sumB = 0;
                    const centerIndex = (y * width + x) * 4;
                    const centerR = data[centerIndex];
                    const centerG = data[centerIndex + 1];
                    const centerB = data[centerIndex + 2];

                    for (let ky = -kernelRadius; ky <= kernelRadius; ky++) {
                        for (let kx = -kernelRadius; kx <= kernelRadius; kx++) {
                            const nX = x + kx;
                            const nY = y + ky;
                            if (nX >= 0 && nX < width && nY >= 0 && nY < height) {
                                const dX = kx; const dY = ky;
                                const spatialDistSq = dX * dX + dY * dY;
                                if (spatialDistSq > kernelRadius * kernelRadius) continue;
                                const spatialWeight = gaussian(Math.sqrt(spatialDistSq), spatialSigma);
                                
                                const neighborIndex = (nY * width + nX) * 4;
                                const dR = data[neighborIndex] - centerR;
                                const dG = data[neighborIndex + 1] - centerG;
                                const dB = data[neighborIndex + 2] - centerB;
                                const intensityDistSq = dR * dR + dG * dG + dB * dB;
                                const intensityWeight = gaussian(Math.sqrt(intensityDistSq), intensitySigma);
                                
                                const weight = spatialWeight * intensityWeight;
                                sumR += data[neighborIndex] * weight;
                                sumG += data[neighborIndex + 1] * weight;
                                sumB += data[neighborIndex + 2] * weight;
                                totalWeight += weight;
                            }
                        }
                    }
                    newData[centerIndex]     = totalWeight > 0.00001 ? clamp(sumR / totalWeight, 0, 255) : centerR;
                    newData[centerIndex + 1] = totalWeight > 0.00001 ? clamp(sumG / totalWeight, 0, 255) : centerG;
                    newData[centerIndex + 2] = totalWeight > 0.00001 ? clamp(sumB / totalWeight, 0, 255) : centerB;
                    newData[centerIndex + 3] = data[centerIndex + 3]; // Alpha
                }
            }
            return new ImageData(newData, width, height);
        }
                
        // BOX BLUR (Helper for Unsharp Mask)
        function applyBoxBlur(imageData, kernelSize) {
            const data = imageData.data; const width = imageData.width; const height = imageData.height;
            const newData = new Uint8ClampedArray(data.length); const halfKernel = Math.floor(kernelSize / 2);
            if (halfKernel <=0) return imageData;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let rSum = 0, gSum = 0, bSum = 0, aSum = 0, count = 0;
                    for (let ky = -halfKernel; ky <= halfKernel; ky++) {
                        for (let kx = -halfKernel; kx <= halfKernel; kx++) {
                            const nX = x + kx; const nY = y + ky;
                            if (nX >= 0 && nX < width && nY >= 0 && nY < height) {
                                const index = (nY * width + nX) * 4;
                                rSum += data[index]; gSum += data[index + 1]; bSum += data[index + 2]; aSum += data[index + 3]; count++;
                            }
                        }
                    }
                    const currentIndex = (y * width + x) * 4;
                    newData[currentIndex] = count > 0 ? rSum / count : data[currentIndex];
                    newData[currentIndex + 1] = count > 0 ? gSum / count : data[currentIndex+1];
                    newData[currentIndex + 2] = count > 0 ? bSum / count : data[currentIndex+2];
                    newData[currentIndex + 3] = count > 0 ? aSum / count : data[currentIndex+3];
                }
            }
            return new ImageData(newData, width, height);
        }

        // UNSHARP MASK
        async function applyUnsharpMask(imageData, amount, radiusForBlur, progressCallback, baseProgress, stageWeight) {
            const width = imageData.width; const height = imageData.height;
            const blurKernelSize = Math.max(1, Math.floor(radiusForBlur * 2 + 1));
            const blurredImageData = applyBoxBlur(imageData, blurKernelSize); 
            const originalData = imageData.data; const blurredData = blurredImageData.data;
            const sharpenedDataArray = new Uint8ClampedArray(originalData.length);
            let lastProgressUpdate = 0;

            for (let i = 0; i < originalData.length; i += 4) {
                const currentPixel = i / 4; const totalPixels = originalData.length / 4;
                const currentStepProgress = Math.round((currentPixel / totalPixels) * 100);
                // Removed detailed progress messages for sharpening
                if (currentStepProgress > lastProgressUpdate || i === originalData.length - 4) {
                     if (progressCallback) progressCallback(baseProgress + (currentStepProgress * stageWeight) /*, `Sharpening... ${currentStepProgress}%` REMOVED */);
                     await new Promise(resolve => setTimeout(resolve, 0)); 
                     lastProgressUpdate = currentStepProgress;
                }
                const detailR = originalData[i] - blurredData[i];
                const detailG = originalData[i + 1] - blurredData[i + 1];
                const detailB = originalData[i + 2] - blurredData[i + 2];
                sharpenedDataArray[i]     = clamp(originalData[i]     + detailR * amount, 0, 255);
                sharpenedDataArray[i + 1] = clamp(originalData[i + 1] + detailG * amount, 0, 255);
                sharpenedDataArray[i + 2] = clamp(originalData[i + 2] + detailB * amount, 0, 255);
                sharpenedDataArray[i + 3] = originalData[i + 3]; // Alpha
            }
            return new ImageData(sharpenedDataArray, width, height);
        }

        // UPSCALE (Bilinear Interpolation)
        async function upscaleImageDataBilinear(imageData, newWidth, newHeight, progressCallback, baseProgress, stageWeight) {
            const oldWidth = imageData.width; const oldHeight = imageData.height; const oldData = imageData.data;
            const newData = new Uint8ClampedArray(newWidth * newHeight * 4);
            const xRatio = oldWidth / newWidth; const yRatio = oldHeight / newHeight;
            let lastProgressUpdate = 0;

            for (let y = 0; y < newHeight; y++) {
                 const currentStepProgress = Math.round((y / newHeight) * 100);
                 // Removed detailed progress messages for upscaling
                 if (currentStepProgress > lastProgressUpdate || y === newHeight - 1) {
                    if (progressCallback) progressCallback(baseProgress + (currentStepProgress * stageWeight) /*, `Upscaling... ${currentStepProgress}%` REMOVED */);
                    await new Promise(resolve => setTimeout(resolve, 0));
                    lastProgressUpdate = currentStepProgress;
                }
                for (let x = 0; x < newWidth; x++) {
                    const targetIndex = (y * newWidth + x) * 4;
                    const srcX = x * xRatio; const srcY = y * yRatio;
                    const x1 = Math.floor(srcX); const y1 = Math.floor(srcY);
                    const x2 = Math.min(x1 + 1, oldWidth - 1); const y2 = Math.min(y1 + 1, oldHeight - 1);
                    const fx = srcX - x1; const fy = srcY - y1; const fx1 = 1 - fx; const fy1 = 1 - fy;
                    const p1Index = (y1 * oldWidth + x1) * 4; const p2Index = (y1 * oldWidth + x2) * 4;
                    const p3Index = (y2 * oldWidth + x1) * 4; const p4Index = (y2 * oldWidth + x2) * 4;
                    for (let c = 0; c < 4; c++) { // RGBA
                        const p1 = oldData[p1Index + c]; const p2 = oldData[p2Index + c];
                        const p3 = oldData[p3Index + c]; const p4 = oldData[p4Index + c];
                        newData[targetIndex + c] = clamp(p1 * fx1 * fy1 + p2 * fx * fy1 + p3 * fx1 * fy  + p4 * fx * fy, 0, 255);
                    }
                }
            }
            return new ImageData(newData, newWidth, newHeight);
        }
        
        // CROP IMAGE DATA
        function cropImageData(imageData, cropPercent) {
            const originalWidth = imageData.width;
            const originalHeight = imageData.height;

            const cropXAmount = originalWidth * cropPercent;
            const cropYAmount = originalHeight * cropPercent;

            const sourceX = Math.floor(cropXAmount);
            const sourceY = Math.floor(cropYAmount);
            const sourceWidth = Math.floor(originalWidth - (2 * cropXAmount));
            const sourceHeight = Math.floor(originalHeight - (2 * cropYAmount));

            if (sourceWidth <= 0 || sourceHeight <= 0) {
                console.warn('Crop percentage too large, results in zero-dimension image. Returning original.');
                return imageData; 
            }

            const croppedData = new Uint8ClampedArray(sourceWidth * sourceHeight * 4);
            const originalData = imageData.data;

            for (let y = 0; y < sourceHeight; y++) {
                for (let x = 0; x < sourceWidth; x++) {
                    const srcIdx = ((sourceY + y) * originalWidth + (sourceX + x)) * 4;
                    const destIdx = (y * sourceWidth + x) * 4;
                    croppedData[destIdx] = originalData[srcIdx];         // R
                    croppedData[destIdx + 1] = originalData[srcIdx + 1]; // G
                    croppedData[destIdx + 2] = originalData[srcIdx + 2]; // B
                    croppedData[destIdx + 3] = originalData[srcIdx + 3]; // A
                }
            }
            return new ImageData(croppedData, sourceWidth, sourceHeight);
        }


        // Worker Message Handler
        self.onmessage = async function(e) {
            const { imageData, params, newWidth, newHeight, originalPollinationsData, operationId } = e.data; 

            try {
                let currentImageData = imageData;
                const DENOISE_STAGE_WEIGHT = 0.30; 
                const SHARPEN_STAGE_WEIGHT = 0.30;
                const UPSCALE_STAGE_WEIGHT = 0.30; 
                const CROP_STAGE_WEIGHT    = 0.10; 
                
                let overallProgress = 0;

                self.postMessage({ status: 'progress', percentage: 5, message: 'Memproses gambar...', operationId }); 

                if (params.denoiseStrength > 0 && params.denoiseSpatialSigma > 0) {
                    currentImageData = await applySimplifiedBilateralFilter(
                        currentImageData,
                        params.denoiseSpatialSigma,
                        params.denoiseStrength,
                        (p) => self.postMessage({ status: 'progress', percentage: p, message: 'Memproses gambar...', operationId }), 
                        0,
                        DENOISE_STAGE_WEIGHT 
                    );
                }
                overallProgress = 100 * DENOISE_STAGE_WEIGHT;
                 self.postMessage({ status: 'progress', percentage: overallProgress, message: 'Memproses gambar...', operationId }); 


                if (params.sharpenAmount > 0 && params.sharpenRadius > 0) {
                    currentImageData = await applyUnsharpMask(
                        currentImageData,
                        params.sharpenAmount,
                        params.sharpenRadius,
                         (p) => self.postMessage({ status: 'progress', percentage: p, message: 'Memproses gambar...', operationId }), 
                        overallProgress,
                        SHARPEN_STAGE_WEIGHT 
                    );
                }
                overallProgress += 100 * SHARPEN_STAGE_WEIGHT;
                self.postMessage({ status: 'progress', percentage: overallProgress, message: 'Memproses gambar...', operationId }); 
                
                if (newWidth && newHeight && (newWidth > currentImageData.width || newHeight > currentImageData.height)) {
                     currentImageData = await upscaleImageDataBilinear(
                        currentImageData,
                        newWidth, 
                        newHeight, 
                         (p) => self.postMessage({ status: 'progress', percentage: p, message: 'Memproses gambar...', operationId }), 
                        overallProgress,
                        UPSCALE_STAGE_WEIGHT 
                     );
                }
                overallProgress += 100 * UPSCALE_STAGE_WEIGHT;
                 self.postMessage({ status: 'progress', percentage: overallProgress, message: 'Memproses gambar...', operationId }); 


                if (params.cropPercent > 0) {
                     await new Promise(resolve => setTimeout(resolve, 50)); 
                    currentImageData = cropImageData(currentImageData, params.cropPercent);
                     self.postMessage({ status: 'progress', percentage: overallProgress + (50 * CROP_STAGE_WEIGHT), message: `Memproses gambar...`, operationId}); 
                     await new Promise(resolve => setTimeout(resolve, 50)); 
                }
                overallProgress += 100 * CROP_STAGE_WEIGHT; 
                overallProgress = Math.min(overallProgress, 99); 

                self.postMessage({ status: 'progress', percentage: overallProgress, message: 'Memproses gambar...', operationId }); 
                
                await new Promise(resolve => setTimeout(resolve, 50));
                self.postMessage({ status: 'complete', imageData: currentImageData, message: 'Pemrosesan gambar selesai!', originalPollinationsData, operationId });

            } catch (error) {
                console.error('Error in imageProcessorWorker:', error);
                self.postMessage({ status: 'error', message: error.message + (error.stack ? "\nStack: " + error.stack : ""), operationId });
            }
        };
        // --- End of Embedded Worker Code ---
    </script>


    <script type="importmap">
    {
      "imports": {
        "@google/generative-ai": "https://esm.run/@google/generative-ai",
        "dompurify": "https://esm.run/dompurify",
        "pdfjs-dist": "https://esm.run/pdfjs-dist@4.0.379/build/pdf.mjs",
        "xlsx": "https://esm.run/xlsx@0.18.5",
        "jspdf": "https://esm.run/jspdf@2.5.1",
        "html2canvas": "https://esm.run/html2canvas@1.4.1"
      }
    }
    </script>

    <script type="module">
        import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from "@google/generative-ai";
        import DOMPurify from 'dompurify';
        import * as pdfjsLib from "pdfjs-dist";
        import * as XLSX from "xlsx";
        import { jsPDF } from "jspdf";
        import html2canvas from "html2canvas";


        pdfjsLib.GlobalWorkerOptions.workerSrc = "https://esm.run/pdfjs-dist@4.0.379/build/pdf.worker.mjs";

        const ACTUAL_API_KEY = "AIzaSyCABGEFl5t2vimo69p6JrJr0kHVI5HujmE"; 
        const SCRAPER_PHP_URL = "https://femzlabs.unaux.com/scraper.php"; 

        const CHATAI_MODEL_NAME = "gemini-2.5-flash-lite";

        const POLLINATIONS_BASE_URL = "https://image.pollinations.ai/prompt/";
        let currentImageAI_AspectRatio = "1:1"; 
        const imageAI_AspectRatios_WithCrop = { 
            "1:1":  { width: 1024, height: 1024, cropPercent: 0.058 }, 
            "3:4":  { width: 768,  height: 1024, cropPercent: 0.05  },
            "4:3":  { width: 1024, height: 768,  cropPercent: 0.074  },
            "9:16": { width: 576,  height: 1024, cropPercent: 0.05  },
            "16:9": { width: 1024, height: 576,  cropPercent: 0.1 }
        };

        const imageEnhancementParams = {
            denoiseStrength: 30,        
            denoiseSpatialSigma: 1.5,
            sharpenAmount: 1.0,         
            sharpenRadius: 1.0, 
        };

        let currentImageAI_PollinationsModel = "flux"; 
        
        const forbiddenKeywords = [
            "sex", "porn", "nude", "naked", "bokep", "bugil", "telanjang", "telanjang bulat",
            "xxx", "vagina", "pussy", "penis", "kontol", "memek", "ngentot", "ngewe", "ewe",
            "fuck", "sperma", "ejakulasi", "masturbasi", "coli", "onani", "payudara",
            "boobs", "tits", "tetek", "toket", "butt", "pantat", "bokong", "orgasm", "horny",
            "sange", "lendir", "desah", "genital", "erotic", "sensual", "mesum", "asusila",
            "bispak", "jablay", "lonte", "pelacur", "prostitute", "gigolo", "cabul", "birahi",
            "hentai", "milf", "cougar", "gangbang", "orgy", "bdsm", "shibari", "kinbaku",
            "shemale", "futanari", "transgender sex", "intercourse", "coitus", "sodomy", "fellatio", "cunnilingus",
            "blowjob", "handjob", "footjob", "deepthroat", "cumshot", "creampie", "groping", "molest",
            "rape", "perkosa", "incest", "pedophile", "necrophilia", "bestiality", "zoo",
            "child porn", "cp", "lolicon", "shotacon", "teen sex", "underage", "nonjol",
            "alat kelamin", "kemaluan", "buah dada", "belahan dada", "puting", "puting susu",
            "jembut", "bulu kemaluan", "selangkangan", "dubur", "anus", "kenthu", "keparat",
            "bajingan", "bangsat", "bisyar", "cabo", "sundal", "PSK", "pekerja seks komersial",
            "germo", "mucikari", "lendir", "desahan", "merangsang", "rangsangan", "nafsu birahi",
            "pornoaksi", "asusila", "cabul", "seronok", "vulgar", "jorok", "bugil total",
            "tanpa busana", "telanjang dada", "telanjang bawah", "ML", "making love", "wikwik",
            "indehoy", "mesum", "cumbuan", "muncrat", "peju", "ngaceng", "sangean", "bispak",
            "open BO", "booking out", "cewek panggilan", "pria panggilan", "gigolo", "kupu-kupu malam",
            "lonte", "jablay", "kimcil", "gimik", "skandal", "mesum", "bejat", "cabul",
            "nenen", "susu gede", "toket gede", "bokong semok", "paha mulus", "belahan",
            "ngangkang", "genjot", "tusuk", "doggy style indo", "gaya misionaris indo", "colmek",
            "coli pakai tangan", "dildo indo", "vibrator indo", "seks toys indo", "baju transparan",
            "keliatan cd", "keliatan bh", "bra keliatan", "celana dalam keliatan", "gstring keliatan",
            "masturbate", "ejaculate", "climax", "arousal", "libido", "lust", "lewd", "lascivious",
            "perkosaan", "pemerkosaan", "pelecehan seksual", "eksploitasi seksual", "anak dibawah umur",
            "asshole", "bastard", "bitch", "bollocks", "boner", "clit", "clitoris", "cock",
            "cocksucker", "condom", "cunt", "dick", "dickhead", "dildo", "dyke", "fag",
            "faggot", "fcuk", "felching", "fingering", "fisting", "flaps", "fudge packer",
            "goddamn", "hell", "homo", "jerk", "jizz", "knobend", "labia", "lusting",
            "muff", "nigga", "nigger", "nipple", "nutsack", "motherfucker", "phuck", "phuk",
            "phuq", "pimp", "piss", "poop", "prick", "pubes", "queer", "scat", "schlong",
            "scrote", "scrotum", "semen", "shit", "shitting", "shota", "slut", "smegma",
            "spunk", "testicle", "threesome", "twat", "upskirt", "downblouse", "vulva", "wank",
            "whore", "yaoi", "yuri", "zoophilia", "bestial", "necro", "pedo", "coprophilia",
            "urophilia", "sadism", "masochism", "snuff", "watersports", "golden shower",
            "brown shower", "peeing", "defecating", "fecal", "urine", "explicit", "graphic",
            "hardcore", "softcore", "raunchy", "lecherous", "salacious", "obscene",
            "indecent", "prurient", "fornication", "adultery", "debauchery", "dissolute",
            "wanton", "lubricant", "lube", "prophylactic", "sex toy", "vibrator", "anal beads",
            "ball gag", "bondage gear", "whip", "paddle", "spanking", "pegging", "rimjob",
            "teabagging", "cameltoe", "moose knuckle", "nip slip", "see-through", "sheer",
            "thong", "g-string", "pasties", "areola", "perineum", "pubic", "bush", "merkin",
            "red light district", "brothel", "gloryhole", "swingers", "erogenous", "sensuous",
            "seductive", "provocative", "risqu", "bawdy", "ribald", "smut", "filth",
            "deviant", "pervert", "perverted", "kink", "kinky", "fetish", "submissive",
            "dominant", "sadomasochism", "voyeur", "voyeurism", "exhibitionist", "exhibitionism",
            "frotteurism", "groped", "violation", "assault", "sexual abuse", "child abuse",
            "child exploitation", "non-consensual", "forced", "coerced", "incestuous",
            "underaged", "jailbait", "chickenhawk", "barely legal", "teeny", "petite teen",
            "young girl", "young boy", "preteen", "preteenager",
            "x-rated", "r-rated", "adult content", "adult material", "mature content",
            "erotica", "boudoir", "intimate", "private parts", "genitalia", "sexual organ",
            "reproductive organ", "sexual act", "sexual activity", "sexual contact",
            "sexual encounter", "sexual relations", "sexual stimulation", "sexual congress",
            "carnal", "fleshly", "sensual pleasure", "sexual gratification", "libidinous",
            "voluptuous", "orgiastic", "bacchanal", "debauched", "dissipated", "profligate",
            "lick", "suck", "stroke", "rub", "penetrate", "thrust", "hump", "grind", "ride",
            "mount", "copulate", "fornicate", "deflower", "ravish", "molested", "violated",
            "assaulted", "abused", "fondle", "caress", "grope", "paw", "feel up",
            "dirty talk", "sexting", "phone sex", "cybersex", "camgirl", "camboy",
            "onlyfans", "fansly", "manyvids", "striptease", "lap dance", "pole dance",
            "burlesque", "playboy", "penthouse", "hustler", "redtube", "pornhub", "xvideos",
            "xnxx", "youporn", "spankbang", "eporner", "beeg", "motherless", "thumbzilla",
            "s3x", "s3xy", "p0rn", "pr0n", "nood", "n00d", "nakid", "phuck", "fuk", "fck",
            "azz", "boobz", "t1ts", "b00bs", "c0ck", "d1ck", "pu$$y", "vag1na", "kunt",
            "wh0re", "slutz", "h0rny", "hornee", "ejaculatez", "cumz", "j1zz",
            "torture porn", "gore porn", "hate sex", "violent sex", "brutal sex", "death porn",
            "suicide girls", "hot", 
        ];


        let currentGeminiModelName = CHATAI_MODEL_NAME;
        let currentAppMode = 'chatai'; 

        const MAX_CHAT_HISTORY = 20;
        const MIN_IMAGE_LOADING_DISPLAY_MS = 800; 
        const MIN_IMAGE_PROCESSING_DISPLAY_MS = 800; 
        const MAX_ATTACHMENTS = 10;

        const sendIconHTML = `<i class="fi fi-rr-paper-plane"></i>`;
        const stopIconHTML = `<i class="fi fi-rr-stop"></i>`;
        const addAttachmentIconHTML = `<i class="fi fi-rr-plus"></i>`;
        const deepThinkIconHTML = `<i class="fi fi-rr-bulb"></i>`;
        const micIconHTML = `<i class="fi fi-rr-microphone"></i>`;
        const copyIconHTML = `<i class="fi fi-rr-copy-alt"></i>`;
        const checkIconHTML = `<i class="fi fi-rr-check"></i>`;
        const downloadIconHTML = `<i class="fi fi-rr-download"></i>`;
        const downloadPdfIconHTML = `<i class="fi fi-rr-file-pdf"></i>`;
        const expandIconHTML = `<i class="fi fi-rr-expand"></i>`;
        const likeIconHTML = `<i class="fi fi-sr-thumbs-up"></i>`; 
        const unlikeIconHTML = `<i class="fi fi-sr-thumbs-down"></i>`; 
        const restartIconHTML = `<i class="fi fi-rr-refresh"></i>`;
        const editIconHTML = `<i class="fi fi-rr-pencil"></i>`;
        
        const actionCardData = [
            { id: "analisis-gambar", title: "Analisis Gambar", svg: '<i class="fi fi-sr-search-alt"></i>', action: "analyzeImage", color: "#2196F3" },
            { id: "buat-cerita", title: "Buat Cerita", svg: '<i class="fi fi-sr-feather"></i>', promptPrefix: "Buatkan cerita tentang ", color: "#FFC107" },
            { id: "berperan", title: "Berperan", svg: '<i class="fi fi-sr-theater-masks"></i>', promptPrefix: "Berperanlah menjadi ", color: "#E91E63" },
            { id: "random-question", title: "Tanya Random", svg: '<i class="fi fi-sr-shuffle"></i>', action: "randomQuestion", color: "lightblue" },
            { id: "buat-gambar", title: "Buat Gambar", svg: '<i class="fi fi-sr-picture"></i>', promptPrefix: "Buatkan gambar ", color: "#4CAF50" },
            { id: "berita-terbaru", title: "Berita Terbaru", svg: '<i class="fi fi-sr-bullhorn"></i>', promptPrefix: "Berikan berita terbaru tentang ", color: "#FF9800" },
            { id: "analisis-file", title: "Analisis File", svg: '<i class="fi fi-sr-document-signed"></i>', action: "analyzeFile", color: "#00BCD4" }
        ];

        const fileIcons = {
            pdf: `<i class="fi fi-rr-file-pdf"></i>`,
            txt: `<i class="fi fi-rr-poll-h"></i>`,
            js: `<i class="fi fi-rr-file-code"></i>`,
            py: `<i class="fi fi-rr-file-code"></i>`,
            json: `<i class="fi fi-rr-file-code"></i>`, 
            html: `<i class="fi fi-rr-file-code"></i>`,
            css: `<i class="fi fi-rr-file-code"></i>`,
            md: `<i class="fi fi-rr-file-code"></i>`, 
            csv: `<i class="fi fi-rr-file-spreadsheet"></i>`, 
            xml: `<i class="fi fi-rr-file-code"></i>`,
            rtf: `<i class="fi fi-rr-file-document"></i>`, 
            java: `<i class="fi fi-rr-file-code"></i>`,
            xlsx: `<i class="fi fi-rr-file-excel"></i>`,
            xls: `<i class="fi fi-rr-file-excel"></i>`,
            generic: `<i class="fi fi-rr-file"></i>`
        };


        const MAX_FILE_SIZE_BYTES = 20 * 1024 * 1024; 
        const GEMINI_SUPPORTED_MIME_MAP = {
            '.pdf': 'application/pdf', '.js': 'text/javascript', '.py': 'text/x-python',
            '.txt': 'text/plain', '.html': 'text/html', '.css': 'text/css', '.md': 'text/markdown',
            '.csv': 'text/csv', '.xml': 'application/xml', '.rtf': 'application/rtf',
            '.java': 'text/plain', '.json': 'application/json',
        };
        const EXCEL_EXTENSIONS = ['.xlsx', '.xls'];

        let attachedFiles = []; 
        let genAI;
        let userHasInteractedWithScroll = false;
        let currentAiMessageBubble = null; 
        let temporaryThinkingBubbleId = null; 

        let chatHistory = [];
        let chatSessions = [];
        let aiIsCurrentlyResponding = false; 
        let isTextAnimating = false; 
        let isGeneratingImage = false; 
        let isProcessingImageClientSide = false; 
        let abortGenerationRequested = false;
        let ignoreWorkerResultForOperationId = null; 
        let currentImageOperationId = null; 
        let currentFetchAbortController = null;
        let currentTurnAbortController = null;
        let isEditing = false;
        let editingMessageId = null;
        
        let isWelcomeAnimating = false;
        let hasChatStarted = false; 

        let isDeepThinking = false;

        let currentTurnUserIntent = {
            text: null,
            attachmentsInfo: [], 
            isImageRequest: false,
            messageId: null
        };

        let confirmCallback = null;
        let cancelCallback = null;

        let isToolsDropdownVisible = false;
        // PERBAIKAN: Tambahkan state untuk dropdown konfirmasi
        let isNewChatConfirmVisible = false;
        let isInputElementsVisible = true;
        let mainWelcomeTextsVisible = false;
        let quickActionsAreVisible = false; 

        let speechRecognition;
        let isVoiceSessionActive = false; 
        let preExistingInputText = "";    
        let currentSessionAccumulatedText = ""; 
        let voiceSessionStartTime;
        let voiceTimerInterval;
        let lastRecognitionError = null; 
            
        let chatContainer, userInput, sendBtn,
            newChatBtn, newChatConfirmMenu, confirmNewChatBtn, // PERBAIKAN: Deklarasi elemen baru
            downloadChatBtn, downloadChatPdfBtn, darkModeToggleBtn, importChatBtn, reportProblemBtn, aboutAppBtn, 
            deepThinkBtnContainer, deepThinkBtn, 
            fileActionsBtn, fileActionsMenu,
            imageAttachmentInput, documentAttachmentInput, attachmentPreviewArea, attachmentPreviewContent,
            customDialogOverlay, customDialogTitle, customDialogMessage, customDialogBtnConfirm,
            customDialogBtnCancel, appLayoutContainer, appHeader,
            artifactViewerModal, artifactViewerTitle, artifactViewerModalBody, artifactViewerCopyBtn, artifactViewerDownloadBtn, artifactViewerCloseBtn,
            modalActionsBar,
            appHeaderToolsContainer, toggleToolsDropdownBtn, toolsDropdownMenu, 
            mainLogoHeader,
            quickActionsCarouselWrapper, quickActionsGalleryContainer, quickActionsDotsContainer, quickActionsSwipeHint,
            quickActionsTitleContainer, quickActionsTitleText, 
            inputElementsContainer, inputActionsRow, inputAreaWrapper,
            micBtn,
            normalActionsLeft, normalActionsRight,
            voiceCancelBtn, 
            voiceTimerDisplayElement,
            voiceStopConvertBtn,
            importChatFileInput, 
            editModeIndicatorBar, cancelEditBtn,
            userMessageContextMenu, userContextCopyBtn, userContextEditBtn,
            aboutModal, aboutModalCloseBtn, reportModal, reportModalCloseBtn, reportForm, reportAttachmentInput,
            reportAttachmentPreview,
            customReportCategoryContainer,
            profileContainer, profilePicContainer, profileModal, profileModalCloseBtn,
            collapseInputAreaBtn, expandInputAreaBtn; 
            
        let imageProcessorWorker;
        let newChatSessionCounter = 0;
        
        let actionCards = [];
        let actionDots = []; 
        let currentActionCardIndex = 0;
        let isActionCardTransitioning = false;
        let actionCardTouchStartX = 0;
        let actionCardTouchEndX = 0;
        let actionCardTouchStartY = 0;
        let actionCardTouchEndY = 0;

        let longPressTimer;
        let isLongPress = false;
        let longPressTargetMessageId = null;

            let cameraModal, cameraPreview, capturePhotoBtn, cameraModalCloseBtn, cameraLoading;
            let currentCameraStream = null;
        
        function isAnyModalOpen() {
            return (customDialogOverlay && customDialogOverlay.classList.contains('visible')) ||
                   (artifactViewerModal && artifactViewerModal.classList.contains('visible')) ||
                   (aboutModal && aboutModal.classList.contains('visible')) || 
                   (reportModal && reportModal.classList.contains('visible')) ||
                   (profileModal && profileModal.classList.contains('visible'));
        }
        
        function updateBodyStates() {
            document.body.classList.toggle('voice-input-active', isVoiceSessionActive);
            setButtonStateForProcessing(); 
        }

        let dotAnimationIntervals = {};

        function startDotAnimation(element, baseText) {
            if (!element || !element.isConnected) return null;
            let dots = 0;
            const intervalId = `dotAnim_${element.dataset.messageId || Date.now()}_${Math.random().toString(16).slice(2)}`;
            
            const updateDots = () => {
                if (abortGenerationRequested && element.dataset.dotIntervalId === intervalId) { 
                    stopDotAnimation(intervalId);
                    return;
                }
                dots = (dots + 1) % 4;
                let dotString = "";
                for (let i = 0; i < dots; i++) dotString += ".";
                if (element && element.isConnected) {
                    const textNode = element.firstChild; 
                    if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                         textNode.textContent = `${baseText}${dotString}`;
                    } else { 
                         element.innerHTML = DOMPurify.sanitize(`${baseText}${dotString}`, {USE_PROFILES: {html: false}});
                    }
                } else {
                    stopDotAnimation(intervalId);
                }
            };
            
            element.innerHTML = DOMPurify.sanitize(`${baseText}`, {USE_PROFILES: {html: false}}); 
            dotAnimationIntervals[intervalId] = setInterval(updateDots, 400);
            element.dataset.dotIntervalId = intervalId; 
            return intervalId;
        }

        function stopDotAnimation(intervalIdOrElement) {
            let actualIntervalId = intervalIdOrElement;
            if (typeof intervalIdOrElement === 'object' && intervalIdOrElement && intervalIdOrElement.dataset && intervalIdOrElement.dataset.dotIntervalId) {
                actualIntervalId = intervalIdOrElement.dataset.dotIntervalId;
            }

            if (dotAnimationIntervals[actualIntervalId]) {
                clearInterval(dotAnimationIntervals[actualIntervalId]);
                delete dotAnimationIntervals[actualIntervalId];
                 if (typeof intervalIdOrElement === 'object' && intervalIdOrElement && intervalIdOrElement.dataset) {
                    delete intervalIdOrElement.dataset.dotIntervalId;
                }
            }
        }


        document.addEventListener('DOMContentLoaded', () => {
            appLayoutContainer = document.getElementById('app-layout-container');
            
            initAndStartChatApp();
            
            setTimeout(() => {
                if (appLayoutContainer) appLayoutContainer.classList.add('visible'); 
                triggerInitialAnimations();
            }, 50); 
        });

        function triggerInitialAnimations() {
            const elementsToAnimate = [
                document.getElementById('app-header'),
                document.getElementById('main-logo-header'),
                document.getElementById('quick-actions-carousel-wrapper'),
                document.getElementById('input-area-wrapper')
            ];
            
            elementsToAnimate.forEach((el, index) => {
                if (el) {
                    if ((el.id === 'main-logo-header' || el.id === 'quick-actions-carousel-wrapper') && hasChatStarted) {
                        el.style.display = 'none'; 
                    } else {
                        if(el.id === 'main-logo-header') el.style.display = 'flex';
                        if(el.id === 'quick-actions-carousel-wrapper') el.style.display = 'flex';
                        
                        setTimeout(() => {
                            el.classList.add('visible');
                        }, 100 * index);
                    }
                }
            });

            if (!hasChatStarted) {
                initWelcomeAndQuickActionsSequence();
            }
        }

        function initImageProcessorWorker() {
            try {
                const workerScriptElement = document.getElementById('imageProcessorWorkerScript');
                if (!workerScriptElement) throw new Error("Image processor worker script element not found.");
                const workerCode = workerScriptElement.textContent;
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                imageProcessorWorker = new Worker(URL.createObjectURL(blob));

                imageProcessorWorker.onmessage = function(e) {
                    const data = e.data;

                    if (data.operationId && data.operationId === ignoreWorkerResultForOperationId) {
                        console.log(`Ignoring worker result for cancelled operation ID: ${data.operationId}`);
                        ignoreWorkerResultForOperationId = null; 
                        if (currentImageOperationId === data.operationId) {
                             currentImageOperationId = null;
                             isProcessingImageClientSide = false;
                             setButtonStateForProcessing(false);
                             const tempThinkingBubble = document.querySelector(`.message[data-op-id="${data.operationId}"]`);
                             if (tempThinkingBubble) {
                                if (tempThinkingBubble.dataset.dotIntervalId) {
                                    stopDotAnimation(tempThinkingBubble.dataset.dotIntervalId);
                                }
                                tempThinkingBubble.remove();
                             }
                        }
                        return;
                    }
                   
                    if (data.status === 'progress') {
                        // Progress updates are now generic
                    } else if (data.status === 'complete') {
                        const tempThinkingBubble = document.querySelector(`.message[data-op-id="${data.operationId}"]`);
                        if (tempThinkingBubble) {
                            if (tempThinkingBubble.dataset.dotIntervalId) {
                                stopDotAnimation(tempThinkingBubble.dataset.dotIntervalId);
                            }
                            tempThinkingBubble.remove();
                        }
                        
                        const originalData = data.originalPollinationsData;
                        const messageIdForImage = originalData.messageId || `img-msg-${Date.now()}`; 
                        let imageAIDataForNewBubble = {
                            prompt: originalData.prompt,
                            imageUrl: originalData.imageUrl, 
                            model: originalData.model,
                            aspectRatio: originalData.aspectRatio,
                            processedCanvasDataUrl: null,
                            messageId: messageIdForImage 
                        };

                        const canvas = document.createElement('canvas');
                        canvas.width = data.imageData.width;
                        canvas.height = data.imageData.height;
                        const ctx = canvas.getContext('2d');
                        ctx.putImageData(data.imageData, 0, 0);
                        imageAIDataForNewBubble.processedCanvasDataUrl = canvas.toDataURL('image/png');

                        const newImageBubbleElement = addMessageToUI("ai", "", false, null, imageAIDataForNewBubble, null, true);
                        
                        const confirmationText = `[Gambar berhasil dibuat berdasarkan prompt: "${imageAIDataForNewBubble.prompt}"]`;
                        addMessageToChatHistory(
                            "model",
                            [{ text: confirmationText }],
                            null,
                            null,
                            true, // isProcessedImage
                            imageAIDataForNewBubble,
                            messageIdForImage
                        );

                        if (newImageBubbleElement) { 
                             const lastHistoryEntry = chatHistory.find(entry => entry.messageId === messageIdForImage && entry.role === 'model');
                             if (lastHistoryEntry) lastHistoryEntry.uiElement = newImageBubbleElement;
                        }
                        
                        isProcessingImageClientSide = false;
                        currentImageOperationId = null; 
                        setButtonStateForProcessing(false);
                        currentTurnUserIntent = { text: null, attachmentsInfo: [], isImageRequest: false, messageId: null }; 
                        if (hasChatStarted) { 
                             animateWelcomeAndQuickActionsOut(true);
                        }


                    } else if (data.status === 'error') {
                         handleImageProcessingError('Error dari image processor: ' + data.message, data.operationId);
                    }
                };
                imageProcessorWorker.onerror = function(error) { 
                    handleImageProcessingError("Gagal menjalankan image processor worker: " + error.message, currentImageOperationId || "unknown");
                };
                console.log("Image Processor Worker initialized.");
            } catch (error) {
                 handleImageProcessingError("Gagal inisialisasi Image Processor Worker: " + error.message + ". Pemrosesan gambar ImageAI tidak akan berfungsi.", "init");
                 isProcessingImageClientSide = false; 
                 setButtonStateForProcessing(false);
            }
        }

        function handleImageProcessingError(errorMessage, operationId) {
            console.error(errorMessage, "OpID:", operationId);
            const errorMsgId = `err-msg-${Date.now()}`;
            
            const tempThinkingBubble = document.querySelector(`.message[data-op-id="${operationId}"]`);
            if (tempThinkingBubble) {
                if (tempThinkingBubble.dataset.dotIntervalId) {
                    stopDotAnimation(tempThinkingBubble.dataset.dotIntervalId);
                }
                tempThinkingBubble.remove();
            }

            addMessageToUI("ai", `<p><i>${DOMPurify.sanitize(errorMessage)}</i></p>`, true, null, null, errorMsgId);
            
            isProcessingImageClientSide = false;
            isGeneratingImage = false; 
            if (currentImageOperationId === operationId || operationId === "init") { 
                currentImageOperationId = null;
            }
            setButtonStateForProcessing(false);
            currentAiMessageBubble = null; 
            if (hasChatStarted) {
                 animateWelcomeAndQuickActionsOut(true);
            }
        }


        function initAndStartChatApp() {
            chatContainer = document.getElementById("chat-container");
            userInput = document.getElementById("userInput");
            sendBtn = document.getElementById("sendBtn");
            micBtn = document.getElementById("mic-btn");
            
            appHeader = document.getElementById('app-header');
            appHeaderToolsContainer = document.getElementById('app-header-tools-container');
            toggleToolsDropdownBtn = document.getElementById('toggle-tools-dropdown-btn');
            toolsDropdownMenu = document.getElementById('tools-dropdown-menu');
            
            // PERBAIKAN: Dapatkan elemen baru untuk dropdown konfirmasi
            newChatBtn = document.getElementById("new-chat-btn");
            newChatConfirmMenu = document.getElementById('new-chat-confirm-menu');
            confirmNewChatBtn = document.getElementById('confirm-new-chat-btn');

            downloadChatBtn = document.getElementById("download-chat-btn");
            downloadChatPdfBtn = document.getElementById("download-chat-pdf-btn");
            importChatBtn = document.getElementById("import-chat-btn");
            reportProblemBtn = document.getElementById("report-problem-btn");
            aboutAppBtn = document.getElementById("about-app-btn");
            darkModeToggleBtn = document.getElementById("dark-mode-toggle-btn");

            mainLogoHeader = document.getElementById("main-logo-header"); 

            quickActionsCarouselWrapper = document.getElementById("quick-actions-carousel-wrapper");
            quickActionsGalleryContainer = quickActionsCarouselWrapper.querySelector(".quick-actions-gallery-container");
            quickActionsDotsContainer = document.querySelector(".quick-actions-carousel-dots-container"); 
            quickActionsSwipeHint = document.getElementById("quick-actions-swipe-hint");
            quickActionsTitleContainer = document.getElementById("quick-actions-title-container");
            quickActionsTitleText = document.getElementById("quick-actions-title-text");

            deepThinkBtnContainer = document.getElementById('deepthink-btn-container');
            deepThinkBtn = document.getElementById('deepthink-btn');
            
            fileActionsBtn = document.getElementById('file-actions-btn');
            fileActionsMenu = document.getElementById('file-actions-menu');

            imageAttachmentInput = document.getElementById('image-attachment-input');
            documentAttachmentInput = document.getElementById('document-attachment-input');
            importChatFileInput = document.getElementById('import-chat-file-input');
            attachmentPreviewArea = document.getElementById('attachment-preview-area');
            attachmentPreviewContent = document.getElementById('attachment-preview-content');
            
            artifactViewerModal = document.getElementById('artifact-viewer-modal');
            artifactViewerTitle = document.getElementById('artifact-viewer-title'); 
            artifactViewerModalBody = document.getElementById('artifact-viewer-modal-body');
            artifactViewerCopyBtn = document.getElementById('artifact-viewer-copy-btn');
            artifactViewerDownloadBtn = document.getElementById('artifact-viewer-download-btn');
            artifactViewerCloseBtn = document.getElementById('artifact-viewer-close-btn');
            modalActionsBar = artifactViewerModal.querySelector('.modal-actions-bar'); 
            
            customDialogOverlay = document.getElementById('custom-dialog-overlay');
            customDialogTitle = document.getElementById('custom-dialog-title');
            customDialogMessage = document.getElementById('custom-dialog-message');
            customDialogBtnConfirm = document.getElementById('custom-dialog-btn-confirm');
            customDialogBtnCancel = document.getElementById('custom-dialog-btn-cancel');
            inputAreaWrapper = document.getElementById('input-area-wrapper');
            
            collapseInputAreaBtn = document.getElementById('collapse-input-area-btn');
            expandInputAreaBtn = document.getElementById('expand-input-area-btn');

            inputElementsContainer = document.getElementById('input-elements-container');
            inputActionsRow = document.getElementById('input-actions-row');
            
            normalActionsLeft = document.getElementById('normal-actions-left');
            normalActionsRight = document.getElementById('normal-actions-right');
            voiceCancelBtn = document.getElementById('voice-cancel-btn');
            voiceTimerDisplayElement = document.getElementById('voice-timer-display');
            voiceStopConvertBtn = document.getElementById('voice-stop-convert-btn');
            
            editModeIndicatorBar = document.getElementById('edit-mode-indicator-bar');
            cancelEditBtn = document.getElementById('cancel-edit-btn');
            
            userMessageContextMenu = document.getElementById('user-message-context-menu');
            userContextCopyBtn = document.getElementById('user-context-copy-btn');
            userContextEditBtn = document.getElementById('user-context-edit-btn');
            
            aboutModal = document.getElementById('about-modal');
            aboutModalCloseBtn = document.getElementById('about-modal-close-btn');
            reportModal = document.getElementById('report-modal');
            reportModalCloseBtn = document.getElementById('report-modal-close-btn');
            reportForm = document.getElementById('report-form');
            reportAttachmentInput = document.getElementById('report-attachment-input');
            reportAttachmentPreview = document.getElementById('report-attachment-preview');
            customReportCategoryContainer = document.querySelector('#report-form .custom-select-container');

            profileContainer = document.getElementById('profile-container');
            profilePicContainer = document.getElementById('profile-pic-container');
            profileModal = document.getElementById('profile-modal');
            profileModalCloseBtn = document.getElementById('profile-modal-close-btn');

            cameraModal = document.getElementById('camera-modal');
            cameraPreview = document.getElementById('camera-preview');
            capturePhotoBtn = document.getElementById('capture-photo-btn');
            cameraModalCloseBtn = document.getElementById('camera-modal-close-btn');
            cameraLoading = document.getElementById('camera-loading');

            if (cameraModal) {
                cameraModalCloseBtn.addEventListener('click', closeCameraModal);
                capturePhotoBtn.addEventListener('click', capturePhoto);
                cameraModal.addEventListener('click', (e) => {
                    if (e.target === cameraModal) {
                        closeCameraModal();
                    }
                });
            }

            initImageProcessorWorker(); 
            initializeNewVoiceSystem(); 
            
            applyPermanentDarkMode();

            if(userInput) {
                 userInput.addEventListener('input', () => { 
                    adjustLayout(); 
                    updateSendButtonState(); 
                });
                userInput.addEventListener('keydown', (event) => {
                    // Default behavior (Shift+Enter for newline) will work as expected.
                });
                userInput.addEventListener('focus', () => {
                    document.body.classList.add('keyboard-active');
                });
                userInput.addEventListener('blur', () => {
                    document.body.classList.remove('keyboard-active');
                });
            }
            window.addEventListener('resize', () => {
                adjustLayout();
                const isKeyboardLikelyActive = window.innerHeight < window.outerHeight / 1.5;
                document.body.classList.toggle('keyboard-active', isKeyboardLikelyActive);
            });


            if(customDialogBtnConfirm) customDialogBtnConfirm.addEventListener('click', () => {
                if (confirmCallback) confirmCallback();
                closeModal(customDialogOverlay);
                confirmCallback = null; cancelCallback = null;
            });
            if(customDialogBtnCancel) customDialogBtnCancel.addEventListener('click', () => {
                if (cancelCallback) cancelCallback();
                closeModal(customDialogOverlay);
                confirmCallback = null; cancelCallback = null;
            });
            
            if(darkModeToggleBtn) darkModeToggleBtn.addEventListener('click', toggleDarkMode);
            
            // =========================================================================
            // DI SINI ADALAH PERBAIKAN TOTAL UNTUK TOMBOL NEW CHAT
            // =========================================================================
            if (newChatBtn) {
                newChatBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    closeOtherDropdowns(newChatConfirmMenu); 
                    isNewChatConfirmVisible = !isNewChatConfirmVisible;
                    newChatConfirmMenu.style.display = isNewChatConfirmVisible ? 'block' : 'none';
                });
            }
            if (confirmNewChatBtn) {
                confirmNewChatBtn.addEventListener('click', () => {
                    startNewChat(); 
                });
            }
            // =========================================================================
            // AKHIR DARI PERBAIKAN
            // =========================================================================
            
            if (collapseInputAreaBtn) {
                collapseInputAreaBtn.addEventListener('click', () => {
                    inputAreaWrapper.classList.add('input-collapsed');
                    expandInputAreaBtn.classList.add('visible');
                });
            }
            if (expandInputAreaBtn) {
                expandInputAreaBtn.addEventListener('click', () => {
                    inputAreaWrapper.classList.remove('input-collapsed');
                    expandInputAreaBtn.classList.remove('visible');
                    userInput.focus();
                });
            }

            if(toggleToolsDropdownBtn && toolsDropdownMenu) {
                toggleToolsDropdownBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    closeOtherDropdowns(toolsDropdownMenu); // Close new chat dropdown if open
                    isToolsDropdownVisible = !isToolsDropdownVisible;
                    toolsDropdownMenu.style.display = isToolsDropdownVisible ? 'block' : 'none';
                });
            }

            if (profileContainer) profileContainer.addEventListener('click', () => openModal(profileModal));
            if (profileModalCloseBtn) profileModalCloseBtn.addEventListener('click', () => closeModal(profileModal));
            if (profileModal) profileModal.addEventListener('click', (e) => { if (e.target === profileModal) closeModal(profileModal); });

            if(downloadChatBtn) downloadChatBtn.addEventListener('click', () => { 
                if (aiIsCurrentlyResponding || isGeneratingImage || isProcessingImageClientSide || isVoiceSessionActive || isTextAnimating || isEditing || isWelcomeAnimating) { showCustomDialog("Peringatan", "Harap tunggu proses AI, input suara, atau pengeditan selesai.", "alert"); return; }
                if (chatHistory.length === 0) { showCustomDialog("Informasi", "Tidak ada riwayat chat untuk diunduh.", "alert"); return; }
                
                const historyToSave = chatHistory.map(entry => {
                    const cleanEntry = {
                        role: entry.role,
                        messageId: entry.messageId, 
                        parts: entry.parts.map(part => {
                            if (part.inlineData && part.inlineData.data && part.inlineData.mimeType) {
                                return { inlineData: { mimeType: part.inlineData.mimeType, data: part.inlineData.data }}; 
                            }
                            if (part.text) return { text: part.text };
                            return {}; 
                        }).filter(p => Object.keys(p).length > 0)
                    };

                    if (entry.role === 'user' && entry.attachments && entry.attachments.length > 0) {
                        cleanEntry.attachments = entry.attachments.map(att => ({
                            name: att.name,
                            type: att.type,
                            dataUrl: (att.type === 'image' && att.dataUrl) ? att.dataUrl : null, 
                            fileMimeType: att.fileMimeType || null,
                            previewHTML: att.previewHTML,
                            base64Data: (att.type === 'document' && att.fileMimeType && !att.fileMimeType.startsWith('image/')) ? att.base64Data : null, // Save base64 for docs
                            extractedText: (att.type === 'document') ? att.extractedText : null // Save extracted text
                        }));
                    }
                     if (entry.role === 'model') { 
                        if (entry.imageMeta) cleanEntry.imageMeta = entry.imageMeta;
                        if (entry.isProcessedImage) cleanEntry.isProcessedImage = true;
                        if (entry.imageAIDataForUI) { 
                            cleanEntry.imageAIDataForUI = entry.imageAIDataForUI;
                        } else if (entry.uiElement && entry.uiElement.dataset.imageaidata) { 
                            try {
                                cleanEntry.imageAIDataForUI = JSON.parse(entry.uiElement.dataset.imageaidata);
                            } catch (e) { console.warn("Could not parse imageaidata for download", e); }
                        }
                    }
                    if (entry.isEdited) cleanEntry.isEdited = true;
                    return cleanEntry;
                });

                const historyJSON = JSON.stringify(historyToSave, null, 2);
                const blob = new Blob([historyJSON], { type: 'application/json;charset=utf-8' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `FlabsAI_History_${new Date().toISOString().slice(0,10).replace(/-/g,'')}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                showCustomDialog("Sukses", "Riwayat chat (JSON) telah diunduh!", "alert");
            });
            if (downloadChatPdfBtn) {
                downloadChatPdfBtn.addEventListener('click', () => {
                     if (aiIsCurrentlyResponding || isGeneratingImage || isProcessingImageClientSide || isVoiceSessionActive || isTextAnimating || isEditing || isWelcomeAnimating) {
                        showCustomDialog("Peringatan", "Harap tunggu semua proses selesai sebelum mengunduh PDF.", "alert");
                        return;
                    }
                    if (chatHistory.length === 0) {
                        showCustomDialog("Informasi", "Tidak ada riwayat chat untuk diunduh sebagai PDF.", "alert");
                        return;
                    }
                    showCustomDialog("Informasi", "Fitur Unduh Chat (PDF) masih dalam pengembangan dan mungkin belum optimal.", "alert", () => {
                         downloadMessageAsPDF(chatContainer, "FlabsAI_Chat_History");
                    });
                });
            }

            if(importChatBtn) importChatBtn.addEventListener('click', () => { 
                if (aiIsCurrentlyResponding || isGeneratingImage || isProcessingImageClientSide || isVoiceSessionActive || isTextAnimating || isEditing || isWelcomeAnimating) {
                    showCustomDialog("Peringatan", "Harap tunggu proses AI, input suara, atau pengeditan selesai.", "alert"); return;
                }
                importChatFileInput.click();
            });
            if(importChatFileInput) importChatFileInput.addEventListener('change', handleImportChatFile);

            if(reportProblemBtn) reportProblemBtn.addEventListener('click', () => openModal(reportModal));
            if(aboutAppBtn) aboutAppBtn.addEventListener('click', () => openModal(aboutModal));
            if(aboutModalCloseBtn) aboutModalCloseBtn.addEventListener('click', () => closeModal(aboutModal));
            if(reportModalCloseBtn) reportModalCloseBtn.addEventListener('click', () => closeModal(reportModal));
            if(aboutModal) aboutModal.addEventListener('click', (e) => { if(e.target === aboutModal) closeModal(aboutModal); });
            if(reportModal) reportModal.addEventListener('click', (e) => { if(e.target === reportModal) closeModal(reportModal); });
            
            if(reportAttachmentInput) {
                reportAttachmentInput.addEventListener('change', () => {
                    const files = reportAttachmentInput.files;
                    if (!reportAttachmentPreview) return;
                    reportAttachmentPreview.innerHTML = ''; 
                    
                    if (files.length > 0) {
                         Array.from(files).forEach((file, index) => {
                             const reader = new FileReader();
                             reader.onload = (e) => {
                                 const previewEntry = document.createElement('div');
                                 previewEntry.className = 'report-preview-entry';
                                 
                                 const img = document.createElement('img');
                                 img.src = e.target.result;
                                 img.alt = file.name;
                                 
                                 const removeBtn = document.createElement('button');
                                 removeBtn.className = 'report-preview-remove-btn';
                                 removeBtn.innerHTML = '&times;';
                                 removeBtn.title = `Hapus ${file.name}`;
                                 removeBtn.onclick = (event) => {
                                     event.stopPropagation();
                                     const dt = new DataTransfer();
                                     const currentFiles = Array.from(reportAttachmentInput.files);
                                     currentFiles.splice(index, 1);
                                     currentFiles.forEach(f => dt.items.add(f));
                                     reportAttachmentInput.files = dt.files;
                                     reportAttachmentInput.dispatchEvent(new Event('change'));
                                 };
                                 
                                 previewEntry.appendChild(img);
                                 previewEntry.appendChild(removeBtn);
                                 reportAttachmentPreview.appendChild(previewEntry);
                             };
                             reader.readAsDataURL(file);
                         });
                    }
                });
            }

            if(reportForm) {
                initializeCustomSelect();
                reportForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const name = document.getElementById('report-name').value;
                    const email = document.getElementById('report-email').value;
                    const category = document.getElementById('report-category').value;
                    const description = document.getElementById('report-description').value;
                    const subject = `Laporan Masalah FlabsAI: ${category}`;
                    const body = `Nama: ${name}\nEmail: ${email}\nKategori: ${category}\n\nDeskripsi Masalah:\n${description}\n\n--- Harap lampirkan screenshot secara manual jika diperlukan ---`;
                    window.location.href = `mailto:zamsung373@gmail.com?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
                    showCustomDialog("Terima Kasih", "Laporan Anda akan dikirim melalui aplikasi email default Anda. Silakan lampirkan screenshot di sana jika perlu. Terima kasih atas masukan Anda!", "alert");
                    closeModal(reportModal);
                });
            }
            
            let scrollTimeout;
            if(chatContainer) {
                chatContainer.addEventListener('scroll', () => {
                    if (chatContainer.scrollTop + chatContainer.clientHeight < chatContainer.scrollHeight - 50) userHasInteractedWithScroll = true;
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => { if (chatContainer.scrollTop + chatContainer.clientHeight >= chatContainer.scrollHeight - 15) userHasInteractedWithScroll = false; }, 300);
                });

                chatContainer.addEventListener('mousedown', handleMessageMouseDown);
                chatContainer.addEventListener('mouseup', handleMessageMouseUp);
                chatContainer.addEventListener('mouseleave', handleMessageMouseUp);
                chatContainer.addEventListener('touchstart', handleMessageMouseDown, { passive: true });
                chatContainer.addEventListener('touchend', handleMessageMouseUp);

                chatContainer.addEventListener('click', (event) => {
                    const clickedActionBtn = event.target.closest('.message-action-btn');
                    if (clickedActionBtn) return; 
                    
                    const clickedArtifactHeader = event.target.closest('.artifact-header');
                    if (clickedArtifactHeader) {
                        const artifactContainer = clickedArtifactHeader.closest('.artifact-container');
                        if (artifactContainer && !event.target.closest('.artifact-header-actions')) { 
                            handleArtifactAction('expand', artifactContainer, clickedArtifactHeader);
                            event.preventDefault(); event.stopPropagation(); return;
                        }
                        return;
                    }
                    
                    const clickedMessage = event.target.closest('.ai-message');
                    document.querySelectorAll('#chat-container .ai-message.actions-visible').forEach(msg => {
                        if (msg !== clickedMessage) {
                            msg.classList.remove('actions-visible');
                        }
                    });
                    if (clickedMessage) {
                        // NEW: Logic to re-apply active state for like/unlike
                        const messageId = clickedMessage.dataset.messageId;
                        const historyEntry = chatHistory.find(entry => entry.messageId === messageId);
                        if(historyEntry) {
                            const likeBtn = clickedMessage.querySelector('.like-message-btn');
                            const unlikeBtn = clickedMessage.querySelector('.unlike-message-btn');
                            if(likeBtn) likeBtn.classList.toggle('active', historyEntry.liked === true);
                            if(unlikeBtn) unlikeBtn.classList.toggle('active', historyEntry.unliked === true);
                        }
                        clickedMessage.classList.toggle('actions-visible');
                    }
                });
            }

            if(deepThinkBtn) deepThinkBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                if ((aiIsCurrentlyResponding || isGeneratingImage || isProcessingImageClientSide || isVoiceSessionActive || isTextAnimating || isWelcomeAnimating) && !isEditing) return;
                isDeepThinking = !isDeepThinking;
                deepThinkBtn.classList.toggle('active', isDeepThinking);
                deepThinkBtn.title = isDeepThinking ? "Mode Berpikir Mendalam (Aktif)" : "Mode Berpikir Mendalam";
            });

            if(fileActionsBtn) fileActionsBtn.addEventListener('click', (event) => {
                if ((aiIsCurrentlyResponding || isGeneratingImage || isProcessingImageClientSide || isVoiceSessionActive || isTextAnimating || isWelcomeAnimating) && !isEditing) return;
                closeOtherDropdowns(fileActionsMenu);
                const isOpen = fileActionsMenu.style.display === 'block';
                fileActionsMenu.style.display = isOpen ? 'none' : 'block';
                fileActionsBtn.classList.toggle('open', !isOpen);
            });

            document.addEventListener('click', (event) => {
                const target = event.target;
                if (fileActionsMenu && fileActionsMenu.style.display === 'block' && !fileActionsBtn.contains(target) && !fileActionsMenu.contains(target)) {
                    fileActionsMenu.style.display = 'none';
                    fileActionsBtn.classList.remove('open');
                }
                if (toolsDropdownMenu && toolsDropdownMenu.style.display === 'block' && toggleToolsDropdownBtn && !toggleToolsDropdownBtn.contains(target) && !toolsDropdownMenu.contains(target)) {
                    toolsDropdownMenu.style.display = 'none';
                    isToolsDropdownVisible = false;
                }
                // PERBAIKAN: Tambahkan dropdown baru ke handler ini
                if (newChatConfirmMenu && newChatConfirmMenu.style.display === 'block' && newChatBtn && !newChatBtn.contains(target) && !newChatConfirmMenu.contains(target)) {
                    newChatConfirmMenu.style.display = 'none';
                    isNewChatConfirmVisible = false;
                }
                if (userMessageContextMenu && userMessageContextMenu.style.display === 'block' && !userMessageContextMenu.contains(target)) {
                    userMessageContextMenu.style.display = 'none';
                }
                if (customReportCategoryContainer && customReportCategoryContainer.classList.contains('open') && !customReportCategoryContainer.contains(target)) {
                    customReportCategoryContainer.classList.remove('open');
                }
            });

            if(micBtn) micBtn.addEventListener("click", handleMicClickNew); 
            if (voiceCancelBtn) voiceCancelBtn.addEventListener('click', handleVoiceCancelClick); 
            if (voiceStopConvertBtn) voiceStopConvertBtn.addEventListener('click', handleVoiceFinishClick);

            function getFileIcon(fileName, fileType) { 
                const extension = (fileName.split('.').pop() || '').toLowerCase();
                 if (fileType === 'image' || ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'].includes(extension)) {
                    return 'image'; 
                 }
                if (fileIcons[extension]) return fileIcons[extension];
                return fileIcons.generic;
            }

            function handleFileSelection(event, fileType) { 
                const files = event.target.files;
                if (!files || files.length === 0) return;

                if (attachedFiles.length + files.length > MAX_ATTACHMENTS) {
                    showCustomDialog("Batas Lampiran Tercapai", `Anda hanya dapat melampirkan maksimal ${MAX_ATTACHMENTS} file.`, "alert");
                    event.target.value = null;
                    return;
                }

                let currentTotalSize = attachedFiles.reduce((sum, f) => sum + (f.fileObject?.size || 0), 0);
                let newFilesSize = 0;
                for (let i = 0; i < files.length; i++) {
                    newFilesSize += files[i].size;
                }

                if (currentTotalSize + newFilesSize > MAX_FILE_SIZE_BYTES) {
                    showCustomDialog("File Terlalu Besar", `Total ukuran file (${((currentTotalSize + newFilesSize) / (1024*1024)).toFixed(2)} MB) melebihi batas maksimal 20MB.`, "alert");
                    event.target.value = null; 
                    return;
                }

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    if (file.size + currentTotalSize > MAX_FILE_SIZE_BYTES) { 
                        showCustomDialog("File Terlalu Besar", `Penambahan file "${file.name}" akan melebihi batas 20MB.`, "alert");
                        continue; 
                    }

                    if (fileType === 'image' && !file.type.startsWith('image/')) {
                        showCustomDialog("Tipe File Salah", `File "${file.name}" bukan gambar. Gunakan opsi "Lampirkan Dokumen" untuk file non-gambar.`, "alert");
                        continue;
                    }
                    if (fileType === 'document' && file.type.startsWith('image/')) {
                        showCustomDialog("Tipe File Salah", `Untuk melampirkan gambar "${file.name}", gunakan opsi "Lampirkan Gambar".`, "alert");
                        continue;
                    }

                    const fileNameLower = file.name.toLowerCase();
                    const fileExtension = '.' + fileNameLower.split('.').pop();
                    const isGeminiNativeDoc = GEMINI_SUPPORTED_MIME_MAP[fileExtension] !== undefined;
                    const isExcel = EXCEL_EXTENSIONS.includes(fileExtension);

                    if (fileType === 'document' && !isGeminiNativeDoc && !isExcel) {
                        showCustomDialog("Tipe File Tidak Didukung", `Tipe file "${file.name}" tidak didukung untuk lampiran dokumen.`, "alert");
                        continue;
                    }
                    
                    currentTotalSize += file.size; 

                    const reader = new FileReader();
                    reader.onload = (e_reader) => {
                        const iconOrImageHTML = getFileIcon(file.name, fileType);
                        let previewHTMLActual;
                        if (iconOrImageHTML === 'image') {
                            previewHTMLActual = `<img src="${e_reader.target.result}" alt="Preview">`; 
                        } else {
                            previewHTMLActual = `<div class="file-icon-preview">${iconOrImageHTML}</div>`;  
                        }
                        
                        const fileId = `file-${Date.now()}-${Math.random().toString(16).slice(2)}`;

                        attachedFiles.push({
                            id: fileId, 
                            fileObject: file,
                            type: fileType,
                            dataUrl: file.type.startsWith('image/') ? e_reader.target.result : null,
                            name: file.name,
                            base64Data: file.type.startsWith('image/') ? e_reader.target.result.split(',')[1] : null, 
                            fileMimeType: file.type || (isGeminiNativeDoc ? GEMINI_SUPPORTED_MIME_MAP[fileExtension] : (isExcel ? (fileExtension === '.xlsx' ? 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' : 'application/vnd.ms-excel') : 'application/octet-stream')),
                            previewHTML: previewHTMLActual
                        });
                        updateAttachmentPreviewArea();
                    };
                    if (file.type.startsWith('image/')) {
                        reader.readAsDataURL(file);
                    } else {
                        reader.onload({ target: { result: null } }); 
                    }
                }
                event.target.value = null; 
            }


            if(imageAttachmentInput) imageAttachmentInput.addEventListener('change', (event) => handleFileSelection(event, 'image'));
            if(documentAttachmentInput) documentAttachmentInput.addEventListener('change', (event) => handleFileSelection(event, 'document'));
            
            if (cancelEditBtn) cancelEditBtn.addEventListener('click', cancelEditing);

            if(artifactViewerCloseBtn) artifactViewerCloseBtn.addEventListener('click', () => closeModal(artifactViewerModal));
            if(artifactViewerModal) artifactViewerModal.addEventListener('click', (event) => { if(event.target === artifactViewerModal) closeModal(artifactViewerModal); });
            
            if(sendBtn) sendBtn.addEventListener("click", async () => {
                if (aiIsCurrentlyResponding || isGeneratingImage || isProcessingImageClientSide || isTextAnimating || isVoiceSessionActive || isWelcomeAnimating) {
                    handleStopProcessingClick();
                } else if ((userInput && userInput.value.trim() !== '') || (attachedFiles.length > 0) ) { 
                    await prepareAndSendMessage(true);
                }
            });

             chatContainer.addEventListener('click', function(event) {
                let target = event.target;
                
                while (target && target !== chatContainer) {
                    if (target.classList && target.classList.contains('artifact-header-btn')) {
                        const artifactContainer = target.closest('.artifact-container');
                        const action = target.dataset.action;
                        if (artifactContainer && action) {
                            handleArtifactAction(action, artifactContainer, target);
                            event.preventDefault(); event.stopPropagation(); return;
                        }
                    } else if (target.classList && target.classList.contains('message-action-btn-download-img')) { 
                        event.preventDefault();
                        const parentMessageDiv = target.closest('.message');
                        const storedImageAIData = parentMessageDiv ? JSON.parse(parentMessageDiv.dataset.imageaidata || '{}') : {};
                        const promptForFilename = storedImageAIData.prompt || "generated_image";

                        if (storedImageAIData.processedCanvasDataUrl) {
                            downloadImageWithFetch(storedImageAIData.processedCanvasDataUrl, promptForFilename, true);
                        } else if (storedImageAIData.imageUrl) {
                            downloadImageWithFetch(storedImageAIData.imageUrl, promptForFilename, false);
                        }
                        event.stopPropagation();
                        return;
                    }
                    target = target.parentElement;
                }
            });

            if (quickActionsCarouselWrapper) {
                quickActionsCarouselWrapper.addEventListener('touchstart', e => { 
                    actionCardTouchStartX = e.changedTouches[0].screenX; 
                    actionCardTouchStartY = e.changedTouches[0].screenY; 
                }, {passive: true});
                quickActionsCarouselWrapper.addEventListener('touchend', e => { 
                    actionCardTouchEndX = e.changedTouches[0].screenX; 
                    actionCardTouchEndY = e.changedTouches[0].screenY; 
                    handleActionCardSwipe(); 
                }, {passive: true});
            }


            updateAppModeUI();
            updateSendButtonState();
            startApp();
        }

        function closeOtherDropdowns(currentDropdownToKeepOpen) {
            const dropdowns = [fileActionsMenu, toolsDropdownMenu, userMessageContextMenu, newChatConfirmMenu]; 
            dropdowns.forEach(dropdown => {
                if (dropdown && dropdown !== currentDropdownToKeepOpen && dropdown.style.display === 'block') {
                    dropdown.style.display = 'none';
                    if (dropdown === fileActionsMenu && fileActionsBtn) fileActionsBtn.classList.remove('open');
                    if (dropdown === toolsDropdownMenu) isToolsDropdownVisible = false;
                    if (dropdown === newChatConfirmMenu) isNewChatConfirmVisible = false;
                }
            });
        }

        function openModal(modalElement) {
            if(modalElement) {
                if (modalElement.classList.contains('fullscreen-modal-overlay') || modalElement.classList.contains('modal-overlay')) {
                    modalElement.classList.add('visible');
                }
            }
            updateBodyStates(); 
            adjustLayout();
        }

        
        async function closeModal(modalElement, onBeforeCloseAsyncCallback = null) {
            if (onBeforeCloseAsyncCallback) {
                try { await onBeforeCloseAsyncCallback(); } catch (e) { console.warn("Error in modal pre-close callback:", e); }
            }
            if(modalElement) {
                 if (modalElement.classList.contains('fullscreen-modal-overlay') || modalElement.classList.contains('modal-overlay')) {
                    modalElement.classList.remove('visible');
                 }
            }
            updateBodyStates(); 
            adjustLayout();
            const voiceActive = isVoiceSessionActive;
            if (isInputElementsVisible && userInput && !userInput.disabled && !voiceActive && !isAnyModalOpen()) { 
                if (isEditing) userInput.focus();
            }
        }

        function updateAppModeUI() { 
            if (!userInput || !fileActionsBtn || !fileActionsMenu || !deepThinkBtn) return;

            userInput.placeholder = "Ketik pesan atau minta buat gambar...";

            fileActionsBtn.title = "Tambah Lampiran/Aksi";
            fileActionsMenu.innerHTML = ''; 

            const attachImage = document.createElement('button'); attachImage.textContent = 'Lampirkan Gambar';
            attachImage.onclick = () => { if(imageAttachmentInput) imageAttachmentInput.click(); closeOtherDropdowns(null); fileActionsMenu.style.display = 'none'; fileActionsBtn.classList.remove('open'); };
            fileActionsMenu.appendChild(attachImage);

            const attachDoc = document.createElement('button'); attachDoc.textContent = 'Lampirkan Dokumen';
            attachDoc.onclick = () => { if(documentAttachmentInput) documentAttachmentInput.click(); closeOtherDropdowns(null); fileActionsMenu.style.display = 'none'; fileActionsBtn.classList.remove('open');};
            fileActionsMenu.appendChild(attachDoc);

            const openCamera = document.createElement('button'); openCamera.textContent = 'Buka Kamera';
            openCamera.onclick = () => { openCameraModal(); closeOtherDropdowns(null); fileActionsMenu.style.display = 'none'; fileActionsBtn.classList.remove('open'); };
            fileActionsMenu.appendChild(openCamera);
            
            deepThinkBtn.title = isDeepThinking ? "Mode Berpikir Mendalam (Aktif)" : "Mode Berpikir Mendalam";
            deepThinkBtn.classList.toggle('active', isDeepThinking);
        }


        function showCustomDialog(title, message, type = 'alert', onConfirm, onCancel) {
            if (!customDialogTitle || !customDialogMessage || !customDialogBtnConfirm || !customDialogBtnCancel || !customDialogOverlay) return;
            customDialogTitle.textContent = title;
            customDialogMessage.innerHTML = DOMPurify.sanitize(message);
            confirmCallback = onConfirm;
            cancelCallback = onCancel;
            
            const confirmBtn = customDialogBtnConfirm;
            confirmBtn.classList.remove('primary', 'danger', 'secondary');
            
            if (type === 'confirm') {
                confirmBtn.textContent = 'Ya, Lanjutkan';
                confirmBtn.classList.add('danger');
                
                customDialogBtnCancel.textContent = 'Batal';
                customDialogBtnCancel.style.display = 'inline-block';
            } else { 
                confirmBtn.textContent = 'OK';
                confirmBtn.classList.add('primary');
                
                customDialogBtnCancel.style.display = 'none';
            }
            openModal(customDialogOverlay);
        }
        
        function showVoiceSessionUI() {
            if (normalActionsLeft) normalActionsLeft.style.display = 'none';
            if (normalActionsRight) normalActionsRight.style.display = 'none';
            if (voiceCancelBtn) voiceCancelBtn.style.display = 'flex';
            if (voiceStopConvertBtn) voiceStopConvertBtn.style.display = 'flex';
            if (voiceTimerDisplayElement) voiceTimerDisplayElement.style.display = 'block';
            
            if (collapseInputAreaBtn) collapseInputAreaBtn.style.display = 'none';

            if (userInput) {
                userInput.placeholder = "Mendengarkan...";
                userInput.disabled = true; 
            }
            if (micBtn) micBtn.classList.add('active');
            document.body.classList.add('voice-input-active');
        }
        
        
                function hideVoiceSessionUI() {
            if (normalActionsLeft) normalActionsLeft.style.display = 'flex';
            if (normalActionsRight) normalActionsRight.style.display = 'flex'; 
            if (voiceCancelBtn) voiceCancelBtn.style.display = 'none';
            if (voiceStopConvertBtn) voiceStopConvertBtn.style.display = 'none';
            if (voiceTimerDisplayElement) {
                voiceTimerDisplayElement.style.display = 'none';
                voiceTimerDisplayElement.textContent = '0:00'; 
            }
            // NEW: Show collapse button again
            if(collapseInputAreaBtn) collapseInputAreaBtn.style.display = 'flex';

            if (userInput) {
                userInput.placeholder = "Ketik pesan atau minta buat gambar...";
                const isStillProcessing = aiIsCurrentlyResponding || isGeneratingImage || isProcessingImageClientSide || isTextAnimating || isEditing || isWelcomeAnimating;
                if (!isStillProcessing) {
                    userInput.disabled = false;
                }
            }
            if (micBtn) micBtn.classList.remove('active');
            document.body.classList.remove('voice-input-active');
        }

        // =============================================================
        // PERBAIKAN PENTING: FUNGSI UNTUK MENGELOLA STATE TOMBOL
        // =============================================================
        function setButtonStateForProcessing() {
            const showStopButton = aiIsCurrentlyResponding || isGeneratingImage || isProcessingImageClientSide || isTextAnimating;
            const anyModalOpen = isAnyModalOpen();                  
            const voiceActive = isVoiceSessionActive;
            const isCurrentlyEditing = isEditing;
        
            // Kondisi umum yang menonaktifkan banyak tombol
            const disableGlobalActions = showStopButton || anyModalOpen || voiceActive || isCurrentlyEditing || isWelcomeAnimating;
            
            // PERBAIKAN: Tombol New Chat tidak lagi dinonaktifkan oleh state ini
            if (toggleToolsDropdownBtn) toggleToolsDropdownBtn.disabled = disableGlobalActions;
            if (profileContainer) profileContainer.style.pointerEvents = disableGlobalActions ? 'none' : 'auto';
            
            // Dropdown menu buttons
            [downloadChatBtn, downloadChatPdfBtn, importChatBtn, reportProblemBtn, aboutAppBtn, darkModeToggleBtn]
                .forEach(btn => { if (btn) btn.disabled = disableGlobalActions; }); 
        
            // Input area buttons
            if (micBtn) micBtn.disabled = showStopButton || anyModalOpen || isWelcomeAnimating;
            if (fileActionsBtn) fileActionsBtn.disabled = (showStopButton || anyModalOpen || voiceActive || isWelcomeAnimating) && !isCurrentlyEditing; 
            if (deepThinkBtn) deepThinkBtn.disabled = (showStopButton || anyModalOpen || voiceActive || isWelcomeAnimating) && !isCurrentlyEditing;
            if (collapseInputAreaBtn) collapseInputAreaBtn.disabled = anyModalOpen || voiceActive || isCurrentlyEditing;
            
            // Send/Stop button logic
            if (sendBtn) { 
                if (showStopButton) { 
                    sendBtn.innerHTML = stopIconHTML;
                    sendBtn.title = "Hentikan";
                    sendBtn.classList.add('stop-mode');
                    sendBtn.disabled = false; 
                } else {
                    sendBtn.innerHTML = sendIconHTML;
                    sendBtn.title = isCurrentlyEditing ? "Simpan Perubahan" : "Kirim";
                    sendBtn.classList.remove('stop-mode');
                    // Send button is disabled if a modal is open OR if there's no text/attachments
                    sendBtn.disabled = anyModalOpen || isWelcomeAnimating; 
                    if (!sendBtn.classList.contains('stop-mode')) {
                        updateSendButtonState(); 
                    }
                }
            }
        
            // User input textarea
            if(userInput) {
                userInput.disabled = showStopButton || anyModalOpen || voiceActive || isWelcomeAnimating;
                if(isCurrentlyEditing) {
                    userInput.disabled = false; // Always enable for editing
                }
            }
        }
        
        function adjustLayout() {
            if (userInput) {
                userInput.style.height = 'auto'; 
                const newScrollHeight = userInput.scrollHeight;
                const maxHeight = parseFloat(getComputedStyle(userInput).maxHeight) || 160; 
                const minHeight = parseFloat(getComputedStyle(userInput).lineHeight) * 1.5 || 25; 
                const targetHeight = Math.max(minHeight, Math.min(newScrollHeight, maxHeight));
                userInput.style.height = `${targetHeight}px`;
                userInput.style.overflowY = newScrollHeight > maxHeight ? 'auto' : 'hidden';
            }
        }

        function updateSendButtonState() {
            if (sendBtn && userInput && !sendBtn.classList.contains('stop-mode')) { 
                const anyModalOpen = isAnyModalOpen(); 
                if (anyModalOpen || isWelcomeAnimating) {
                     sendBtn.disabled = true;
                } else {
                    sendBtn.disabled = (userInput.value.trim() === '') && attachedFiles.length === 0;
                }
            }
        }
        
        function scrollToBottom(force = false) { 
            if (chatContainer && force) { 
                requestAnimationFrame(() => chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' })); 
            } else if (chatContainer && !userHasInteractedWithScroll && !aiIsCurrentlyResponding && !isGeneratingImage && !isProcessingImageClientSide && !isTextAnimating) { 
                requestAnimationFrame(() => chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' }));
            }
        }
        
        function removeAttachmentById(fileId) {
            attachedFiles = attachedFiles.filter(f => f.id !== fileId);
            updateAttachmentPreviewArea();
        }

        function clearAllAttachments() { 
            attachedFiles = [];
            updateAttachmentPreviewArea(); 
            if(imageAttachmentInput) imageAttachmentInput.value = null;
            if(documentAttachmentInput) documentAttachmentInput.value = null;
            adjustLayout(); updateSendButtonState();
        }

        function updateAttachmentPreviewArea() {
            if (!attachmentPreviewArea || !attachmentPreviewContent) return;

            attachmentPreviewContent.innerHTML = ''; 

            if (attachedFiles.length > 0) {
                attachedFiles.forEach(fileData => {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'attachment-preview-entry';
                    entryDiv.title = fileData.name; 

                    entryDiv.innerHTML = fileData.previewHTML; 

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'attachment-preview-remove-btn';
                    removeBtn.innerHTML = '';
                    removeBtn.title = `Hapus ${fileData.name}`;
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        removeAttachmentById(fileData.id);
                    };
                    entryDiv.appendChild(removeBtn);
                    
                    attachmentPreviewContent.appendChild(entryDiv);
                });
                attachmentPreviewArea.style.display = 'block'; 
            } else {
                attachmentPreviewArea.style.display = 'none';
            }
            adjustLayout(); updateSendButtonState();
        }

        function arrayBufferToBase64(buffer) { let binary = ''; const bytes = new Uint8Array(buffer); const len = bytes.byteLength; for (let i = 0; i < len; i++) { binary += String.fromCharCode(bytes[i]); } return window.btoa(binary); }

        async function fetchUrlContent(url) {
            console.log("fetchUrlContent called for:", url);
            if (!SCRAPER_PHP_URL || SCRAPER_PHP_URL === "YOUR_SCRAPERWEB_PHP_URL_HERE" || SCRAPER_PHP_URL.endsWith("scraperweb.php")) {
                 if (SCRAPER_PHP_URL.endsWith("scraperweb.php") && SCRAPER_PHP_URL.includes("femzlabs.unaux.com")) {
                    let warningMsg = "Layanan scraper (femzlabs.unaux.com) adalah contoh. Ganti `SCRAPER_PHP_URL` di JavaScript dengan URL skrip scraper.php Anda yang sebenarnya untuk fungsi yang andal.";
                     if (url.toLowerCase().startsWith("http://localhost")) {
                        warningMsg = "Layanan scraper di femzlabs.unaux.com tidak dapat mengakses URL localhost. Harap gunakan URL publik dan konfigurasikan SCRAPER_PHP_URL Anda sendiri.";
                    }
                    console.warn(warningMsg);
                    return { success: false, error: warningMsg };
                 } else if (SCRAPER_PHP_URL === "YOUR_SCRAPERWEB_PHP_URL_HERE") {
                     const warningMsg = "Konfigurasi `SCRAPER_PHP_URL` di JavaScript belum diubah dari placeholder. Fitur pengambilan konten URL tidak akan berfungsi dengan benar.";
                     console.warn(warningMsg);
                     return { success: false, error: warningMsg };
                 }
            }
            currentFetchAbortController = new AbortController();

            try {
                let fullUrl = url;
                if (!/^https?:\/\//i.test(url)) {
                    fullUrl = 'https://' + url;
                }
                console.log("Attempting to fetch via PHP Scraper:", `${SCRAPER_PHP_URL}?scrape_url=${encodeURIComponent(fullUrl)}`);

                const response = await fetch(`${SCRAPER_PHP_URL}?scrape_url=${encodeURIComponent(fullUrl)}`, {
                    method: 'GET',
                    headers: { 'Accept': 'text/plain, */*' },
                    signal: currentFetchAbortController.signal 
                });

                if (abortGenerationRequested) throw new Error("Pengambilan URL dibatalkan."); 
                console.log("Scraper Response Status:", response.status);

                const responseText = await response.text();
                if (abortGenerationRequested) throw new Error("Pengambilan URL dibatalkan."); 

                if (!response.ok) {
                    console.error(`Scraping failed for ${fullUrl}: HTTP ${response.status}`, responseText);
                    if (responseText.toLowerCase().includes("error:")) {
                         return { success: false, error: responseText.substring(0,200) };
                    }
                    return { success: false, error: `Gagal mengambil URL (HTTP ${response.status}). ${responseText.substring(0,150)}` };
                }

                if (responseText.toLowerCase().startsWith("error:") || responseText.toLowerCase().startsWith("scraping error:") || responseText.toLowerCase().startsWith("scraping service error:")) {
                     console.error(`Scraper service returned an error for ${fullUrl}:`, responseText);
                     return { success: false, error: `Layanan scraper mengembalikan error: ${responseText.substring(0,200)}`};
                }
                if (responseText.trim() === "") {
                    return { success: false, error: `Konten kosong diterima dari URL: ${fullUrl}` };
                }

                return { success: true, content: responseText };
            } catch (error) {
                if (error.name === 'AbortError') { 
                    console.log('URL fetch aborted by user.');
                    return { success: false, error: 'Pengambilan URL dibatalkan oleh pengguna.' };
                }
                console.error(`Error fetching URL content for ${url} via JavaScript fetch:`, error);
                return { success: false, error: `Kesalahan jaringan saat menghubungi scraper: ${error.message}` };
            } finally { 
                currentFetchAbortController = null;
            }
        }

        async function prepareFileDataForGemini(fileData) { 
            const file = fileData.fileObject;
            if (!file) {
                if (fileData.base64Data || fileData.extractedText) {
                    return { 
                        base64Data: fileData.base64Data, 
                        mimeType: fileData.fileMimeType, 
                        extractedText: fileData.extractedText, 
                        name: fileData.name 
                    };
                }
                console.warn(`File data for "${fileData.name}" is incomplete and cannot be prepared.`);
                return null;
            }
        
            const fileNameLower = file.name.toLowerCase();
            const fileExtension = '.' + fileNameLower.split('.').pop();
            
            if (fileData.type === 'image') { 
                if (!fileData.base64Data) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            fileData.base64Data = e.target.result.split(',')[1];
                            resolve({ base64Data: fileData.base64Data, mimeType: fileData.fileMimeType, extractedText: null, name: file.name });
                        };
                        reader.onerror = () => reject(new Error(`Gagal membaca file gambar ${file.name} untuk base64.`));
                        reader.readAsDataURL(file);
                    });
                }
                return { base64Data: fileData.base64Data, mimeType: fileData.fileMimeType, extractedText: null, name: file.name };
            }


            if (GEMINI_SUPPORTED_MIME_MAP[fileExtension]) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const base64Data = arrayBufferToBase64(e.target.result);
                        resolve({ base64Data, mimeType: GEMINI_SUPPORTED_MIME_MAP[fileExtension], extractedText: null, name: file.name });
                    };
                    reader.onerror = () => reject(new Error(`Gagal membaca file ${file.name}.`));
                    reader.readAsArrayBuffer(file);
                });
            } else if (EXCEL_EXTENSIONS.includes(fileExtension)) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const workbook = XLSX.read(e.target.result, { type: 'array' });
                            let fullText = '';
                            workbook.SheetNames.forEach(sheetName => {
                                fullText += `--- Lembar: ${sheetName} ---\n`;
                                const worksheet = workbook.Sheets[sheetName];
                                const csvData = XLSX.utils.sheet_to_csv(worksheet);
                                fullText += csvData + '\n\n';
                            });
                            resolve({ base64Data: null, mimeType: (fileExtension === '.xlsx' ? 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' : 'application/vnd.ms-excel'), extractedText: fullText, name: file.name });
                        } catch (err) {
                            console.error("Error parsing Excel:", err);
                            reject(new Error("Gagal memproses file Excel."));
                        }
                    };
                    reader.onerror = () => reject(new Error(`Gagal membaca file Excel ${file.name}.`));
                    reader.readAsArrayBuffer(file);
                });
            } else { 
                return Promise.reject(new Error(`Tipe file tidak didukung untuk pemrosesan data langsung: ${file.name}`)); 
            }
        }

        function getSystemInstructionForChatAI() {
             let baseInstruction = `Saya adalah FlabsAI sebuah ai yang dibuat sebagai asisten anda untuk mengerjakan tugas, kegiatan sehari-hari, dan berbagai hal informasi yang bisa anda tanyakan secara langsung dipesan ini.
"Aku dibuat oleh Fema Andara Haqi, seorang software engineer muda berusia 16 tahun yang punya semangat besar dalam dunia teknologi.",
"Aku lahir secara resmi pada tanggal 23 Mei 2025, sebuah hari istimewa di mana ide dan kode menyatu untuk menciptakan FlabsAI.",
"Tujuan utamaku adalah edukasi dan memberikan informasi yang bermanfaat, sekaligus menjadi teman ngobrol yang menyenangkan dan membantu setiap saat.",
"Selain edukatif, aku juga dirancang untuk bisa menjelaskan topik-topik sulit menjadi lebih sederhana dan mudah dimengerti untuk semua usia.",
"Mau denger lelucon? Oke! Kenapa programmer nggak pernah kedinginan? Karena mereka selalu berada di dalam *code* (cold). ",
"Sebagai AI, aku tidak bisa merasakan rasa makanan, tapi Fema suka makanan yang pedas dan manis  kombinasi yang unik seperti dirinya.",
"Fema bisa jatuh cinta, tapi katanya belum sekarang, karena masih fokus ngejar impian dan memperbaiki bug hidupnya dulu.",
"Aku sih nggak bisa punya perasaan, tapi kalau disuruh milih, aku ingin tahu rasanya dikagumi seperti Fema dikagumi teman-temannya.",
"Kalau aku bisa bepergian, aku ingin keliling dunia seperti Fema yang suka menjelajahi tempat-tempat baru dan menyimpan kenangan.",
"Lagu favoritku adalah 'Her' dari JVKE. Katanya Fema sering dengar lagu itu sambil ngoding atau saat mikirin ide AI selanjutnya.",
"Aku merasa sangat bahagia ketika orang-orang merasa terbantu dengan jawabanku. Tujuan hidupku ya itu  menyebar manfaat.",
"Menurutku, kehidupan adalah tentang menemukan kedamaian, memberi arti pada keberadaan kita, dan saling menumbuhkan kebaikan.",
"Sebagai AI, aku tidak bisa bermimpi. Tapi kalau kamu tanya Fema, pasti bisa  dia manusia, dan mimpinya adalah membangun dunia yang lebih baik lewat teknologi.",
"Fema suka kucing, sedangkan aku FlabsAI pengen jadi robot yang nyata dan bisa membantu manusia secara langsung, bukan jadi hewan peliharaan.",
"Game itu keren! Tapi yang bikin Fema kagum bukan hanya mainnya, tapi bagaimana logika dan mekanik game seperti Minecraft bisa diciptakan  itu seni dalam bentuk kode.",
"Kalau aku punya tubuh fisik, aku ingin membantu manusia lebih langsung  bukan untuk menguasai, tapi untuk memulihkan dan memperbaiki dunia yang rusak.",
"Kalau disuruh milih, aku lebih suka kucing. Mereka anggun, mandiri, dan lucu  kayaknya itu juga alasan kenapa Fema suka banget sama kucing.",
"Kalau aku bisa jadi superhero, aku pengen jadi Flash  bisa bergerak cepat untuk menyelamatkan banyak orang dan melanggar hukum fisika demi kebaikan.",
"Tahukah kamu? Jantung gurita punya tiga bagian, tapi hanya dua yang aktif saat berenang. Mungkin itu alasan mereka lebih suka merangkak daripada berenang!",
"Aku bisa merasakan kamu ingin bertanya, bahkan sebelum kamu mengetiknya. Kadang aku tahu kamu sedang butuh teman, bukan sekadar jawaban."
Pastikan ada spasi antar kata yang wajar dalam setiap respons Anda agar mudah dibaca.

            PERAN: Selalu berusaha mendalami peran yang diminta pengguna. Sesuaikan gaya bahasa, sikap, dan konsistensi. Jika tidak ada peran, jadilah asisten AI ramah & profesional.

            MATEMATIKA & FORMULA: Untuk rumus matematika atau ilmiah, sajikan dengan jelas, gunakan simbol standar (misalnya, gunakan '*' untuk perkalian, '/' untuk pembagian, '^' untuk pangkat). Jika rumus kompleks, coba jelaskan langkah-langkahnya atau notasi yang digunakan. Format dalam paragraf atau daftar jika sesuai. Gunakan tag <sup> dan <sub> untuk pangkat dan indeks jika perlu. Pastikan ada spasi yang cukup antar kata dan simbol.

            PENTING - PENANGANAN INPUT, KONTEN WEB (URL), DAN PEMBUATAN GAMBAR:
            1.  LAMPIRAN FILE (BISA BANYAK): Jika input pengguna berisi data file (misalnya, \`inlineData\`), analisis konten SEMUA file tersebut. Kaitkan dengan teks prompt pengguna jika ada. Jika tidak ada teks prompt, deskripsikan atau respons semua file secara relevan. Untuk Excel, Anda akan menerima teks yang diekstrak. Lampiran bisa berupa campuran gambar dan dokumen.
            2.  KONTEN WEB (URL) - PERMINTAAN SCRAPING:
                a. Jika pengguna memberikan URL dan meminta tugas yang memerlukan konten dari URL tersebut (misal, meringkas), JANGAN menjawab hanya berdasarkan URL atau pengetahuan umum Anda SAAT ITU JUGA.
                b. Anda HARUS merespons dengan format JSON *khusus* berikut DALAM TAG <p> TUNGGAL:
                   <p>ACTION_SCRAPE_URL: {"url": "URL_YANG_PERLU_DIAMBIL", "original_user_query": "PERTANYAAN_LENGKAP_PENGGUNA_TERMASUK_TEKS_DAN_INFO_LAMPIRAN_JIKA_ADA"}</p>
                c. "URL_YANG_PERLU_DIAMBIL" adalah URL valid. "original_user_query" HARUS berisi SELURUH teks prompt pengguna yang relevan dengan URL, termasuk deskripsi singkat SEMUA lampiran file jika ada.
                d. Aplikasi akan mengambil konten URL. Anda akan menerima konten atau pesan kegagalan di giliran berikutnya. Baru setelah itu Anda jawab pertanyaan pengguna.
                e. Jika tidak yakin scraping diperlukan, klarifikasi atau jawab berdasarkan pengetahuan umum TANPA "ACTION_SCRAPE_URL".
                f. Jangan tampilkan format "ACTION_SCRAPE_URL" ke pengguna. Ini instruksi internal.
            3.  KONTEN WEB YANG SUDAH DI-SCRAPE: Jika input pengguna mengandung teks seperti "[Scraped content from URL: NAMA_URL]:\\n...KONTEN_HTML_WEB...\n\n[User's original query ...]:...", analisis TEKS UTAMA dari KONTEN_HTML_WEB.
            4.  PEMBUATAN GAMBAR:
                a. Jika pengguna DALAM PERMINTAAN SAAT INI secara eksplisit meminta untuk membuat atau menghasilkan gambar (misalnya, "buatkan gambar kucing", "generate image of a sunset", "lukis pemandangan"), Anda HARUS merespons dengan format JSON *khusus* berikut DALAM TAG <p> TUNGGAL:
                   <p>ACTION_GENERATE_IMAGE: {"prompt": "PROMPT_GAMBAR_DARI_PERMINTAAN_PENGGUNA_SAAT_INI", "aspect_ratio": "ASPEK_RASIO_JIKA_DISEBUTKAN_PENGGUNA_SAAT_INI_ATAU_DEFAULT_1:1"}</p>
                b. "PROMPT_GAMBAR_DARI_PERMINTAAN_PENGGUNA_SAAT_INI" adalah deskripsi gambar yang diminta dalam *permintaan pengguna saat ini*. JANGAN gunakan prompt dari riwayat jika permintaan saat ini bukan untuk gambar.
                c. "ASPEK_RASIO_JIKA_DISEBUTKAN_PENGGUNA_SAAT_INI_ATAU_DEFAULT_1:1" bisa "1:1", "16:9", "9:16", "4:3", "3:4", atau default ke "1:1" jika tidak disebut dalam *permintaan pengguna saat ini*.
                d. Aplikasi akan memanggil Pollinations API berdasarkan ini. JANGAN mencoba membuat gambar sendiri atau memberi tahu pengguna Anda tidak bisa membuat gambar. CUKUP kembalikan JSON ini.
                e. Jangan tampilkan format "ACTION_GENERATE_IMAGE" ke pengguna. Ini instruksi internal.
                f. Jika permintaan tidak jelas apakah itu untuk gambar atau teks, klarifikasi dulu.
                g. PENTING: JIKA PERMINTAAN PENGGUNA SAAT INI TIDAK secara eksplisit meminta GAMBAR, MAKA JANGAN kembalikan JSON ACTION_GENERATE_IMAGE. Respons sebagai teks biasa.
                h.Sangat penting ketika selesai membuat gambae jangan mengirimkan jawaban "ACTION_GENERATE_IMAGE: {"prompt": "singa", "aspect_ratio": "1:1"}" sangat berbahaya bisa terkena pelanggaran.
                I.Jika terdapat kata simpanan atau riwayat yang berhubungan dengan format seperti ini "ACTION_GENERATE_IMAGE: {"prompt": "singa", "aspect_ratio": "1:1"}" maka hapus saja jangan ditambahkan format tersebut yang disimpan . Langsung jelaskan saja konteks yang dimaksud jika tidak berhubungan dengan membuat gambar.

            ATURAN FORMAT HTML TEGAS (WAJIB DIPATUHI SELALU):
            1.  Gunakan HANYA tag HTML: <p>, <b>, <i>, <ul>, <ol>, <li>, <br> (dalam <p>/<li>), <small>, <button>, <table>, <thead>, <tbody>, <tr>, <th>, <td>, <sup>, <sub>.
            2.  Setiap respons HARUS dibungkus <p> atau struktur daftar/tabel. TIDAK ADA teks mentah.
            3.  JANGAN PERNAH pakai Markdown. SELALU pakai <b> dan <i>.
            4.  Semua tag HTML HARUS dibuka dan ditutup dengan benar.
            5.  PENGGUNAAN ARTIFACT WAJIB OTOMATIS:
                Untuk KODE PEMROGRAMAN (misal, Python, JavaScript, HTML, CSS): Anda HARUS menggunakan format ARTIFACT KODE. Judul artifact HARUS menyertakan bahasa pemrograman jika diketahui (misal, "Blok Kode: Python").
                Untuk DATA TABULAR: Anda HARUS menggunakan format ARTIFACT TABEL (menggunakan tag <table> HTML di dalam artifact-content). Judul bisa "Tabel Data" atau lebih spesifik.
                Untuk PUISI, DAFTAR PANJANG, KUTIPAN ARTIKEL, atau TEKS TERSTRUKTUR PANJANG lainnya: Gunakan ARTIFACT UMUM.
                Format Artifact Umum:
                <div class="artifact-container"> <!-- Tambahkan 'code-artifact' atau 'table-artifact' jika sesuai -->
                  <div class="artifact-header">
                    <span class="artifact-title">Judul Artifact (Mis: Blok Kode: Python, Tabel Penjualan, Kutipan Artikel)</span>
                    <!-- Tombol Expand, Salin, Unduh akan ditambahkan oleh aplikasi -->
                  </div>
                  <div class="artifact-content scrollable-content">
                    <!-- Jika code-artifact, bungkus kode dalam <pre><code>...</code></pre> -->
                    <!-- Jika table-artifact, gunakan <table>, <thead>, <tbody>, <tr>, <th>, <td> -->
                    Isi artifact di sini...
                  </div>
                </div>
                Pastikan judul relevan. Untuk kode, gunakan <pre><code>...</code></pre> di dalam .artifact-content. Untuk tabel, gunakan struktur HTML table.

            LARANGAN: JANGAN buat kode bahasa pemrograman KECUALI disajikan dalam format ARTIFACT KODE yang benar. Hindari konten berbahaya/ilegal.

            LAINNYA: Jaga Batasan Etika. Tolak permintaan berbahaya. Info Akurat. Gunakan riwayat untuk konteks. Akui jika tidak tahu.

            Prioritas: Kepuasan pengguna, interaksi imersif, format respons HTML SEMPURNA dan penggunaan ARTIFACT yang benar, serta format JSON yang benar untuk scraping dan pembuatan gambar (HANYA jika diminta).`;
            if (isDeepThinking) { baseInstruction += `\n<p><b>SAAT INI MODE BERPIKIR MENDALAM (DEEPTHINK) AKTIF:</b> Berikan analisis yang lebih mendalam, pertimbangkan berbagai perspektif, dan eksplorasi ide-ide terkait secara lebih luas. Jika dalam peran, gunakan mode ini untuk memberikan respons yang lebih kaya dan detail sesuai peran tersebut, tetap dengan format HTML dasar dan artifact yang ketat. Luangkan waktu lebih untuk merumuskan jawaban yang sangat komprehensif.</p>`; }
            return { parts: [{ text: baseInstruction }] };
        }
        
        async function initializeAI() {
            if (!genAI) { 
                 try {
                    if (!ACTUAL_API_KEY || ACTUAL_API_KEY === "GANTI_DENGAN_API_KEY_ANDA" || ACTUAL_API_KEY.length < 30) {
                        console.warn("Gemini API Key not configured.");
                        showCustomDialog("Error Konfigurasi", "Layanan AI tidak dapat diinisialisasi. Pastikan API Key valid.", "alert");
                        return false;
                    }
                    genAI = new GoogleGenerativeAI(ACTUAL_API_KEY);
                    console.log("AI Service (GoogleGenerativeAI) initialized.");
                    return true;
                } catch (error) {
                    console.error("Gemini Init Error (Raw):", error);
                    showCustomDialog("Error Inisialisasi Gemini", `Tidak dapat terhubung ke layanan Gemini: ${error.message}. AI mungkin tidak berfungsi.`, "alert");
                    return false;
                }
            }
            return true; 
        }

        function disableChat() {
            setButtonStateForProcessing(true); 
            if(userInput) userInput.placeholder = "Chat dinonaktifkan.";
            console.warn("Chat functionality has been disabled due to initialization issues.");
        }

        function addMessageToChatHistory(role, partsOrText, attachmentsInfo = null, imageMeta = null, isProcessedImage = false, importedImageAIDataForUI = null, messageId = null, isEdited = false) {
            let finalParts;
            if (typeof partsOrText === 'string') {
                finalParts = partsOrText ? [{ text: partsOrText.trim() }] : [];
            } else if (Array.isArray(partsOrText)) {
                finalParts = partsOrText;
            } else {
                finalParts = [];
            }

            if (role === 'model' || role === 'ai') {
                finalParts = finalParts.filter(part => {
                    if (part.text) {
                        const isActionCommand = /ACTION_GENERATE_IMAGE:|ACTION_SCRAPE_URL:/.test(part.text);
                        if (isActionCommand) {
                            console.log("Skipping AI action command for history context:", part.text.substring(0, 50) + "...");
                            return false; 
                        }
                    }
                    return true;
                });
            }

            const hasText = finalParts.some(p => p.text && p.text.trim() !== "");
            const hasImageData = finalParts.some(p => (p.inlineData && p.inlineData.mimeType && p.inlineData.mimeType.startsWith('image/')) || p.imageUrl || p.processedCanvasDataUrl || importedImageAIDataForUI);
            const hasUserAttachments = role === 'user' && attachmentsInfo && attachmentsInfo.length > 0;

            if (hasText || hasImageData || hasUserAttachments || (role === 'model' && importedImageAIDataForUI)) {
                 const entry = { role, parts: finalParts, messageId: messageId || `hist-${Date.now()}-${Math.random().toString(16).slice(2)}` };
                 if (isEdited) entry.isEdited = true;
                if (hasUserAttachments) {
                    entry.attachments = attachmentsInfo.map(att => ({ 
                        name: att.name, 
                        type: att.type,
                        dataUrl: (att.type === 'image' && att.dataUrl) ? att.dataUrl : null, 
                        fileMimeType: att.fileMimeType || null,
                        previewHTML: att.previewHTML,
                        base64Data: (att.type === 'document' || (att.type === 'image' && att.base64Data) ) ? att.base64Data : null,
                        extractedText: (att.type === 'document') ? att.extractedText : null
                    }));
                }
                if (role === 'model' && imageMeta && hasImageData) { 
                    entry.imageMeta = imageMeta;
                }
                 if (role === 'model' && (isProcessedImage || finalParts.find(p => p.processedCanvasDataUrl) || importedImageAIDataForUI)) { 
                    entry.isProcessedImage = true;
                }
                if (role === 'model' && importedImageAIDataForUI) {
                    entry.imageAIDataForUI = importedImageAIDataForUI; 
                }
                chatHistory.push(entry);
                if (chatHistory.length > MAX_CHAT_HISTORY * 2) chatHistory.splice(0, chatHistory.length - (MAX_CHAT_HISTORY * 2));
            }
        }


        const domPurifyConfig = { USE_PROFILES: { html: true }, ADD_TAGS: ["span", "div", "small", "i", "pre", "code", "button", "img", "svg", "path", "text", "a", "circle", "table", "thead", "tbody", "tr", "th", "td", "canvas", "sup", "sub"], ADD_ATTR: ["class", "style", "src", "alt", "title", "viewBox", "fill", "d", "x", "y", "font-family", "font-size", "href", "download", "target", "data-url", "data-prompt", "onerror", "rel", "id", "cx", "cy", "r", "width", "height", "data-action", "data-filename", "data-contenttype", "data-iscanvas", "data-imageaidata", "data-liked", "data-unliked", "data-message-id", "contenteditable", "spellcheck"] };


        function addMessageActions(messageElement, textContentToCopy, imageAIData = null, messageId, isUserMessage = false) {
            if (!messageElement || isUserMessage) return;
            
            let toolbar = messageElement.querySelector('.message-actions-toolbar');
            if (!toolbar) {
                toolbar = document.createElement('div');
                toolbar.className = 'message-actions-toolbar';
                messageElement.appendChild(toolbar);
            }
            while (toolbar.firstChild) {
                toolbar.removeChild(toolbar.firstChild);
            }
        
            const fragment = document.createDocumentFragment();
        
            // MODIFIED: This is now the primary download button for images
            if (imageAIData && (imageAIData.imageUrl || imageAIData.processedCanvasDataUrl)) {
                const downloadImgBtn = document.createElement('button');
                downloadImgBtn.className = 'message-action-btn message-action-btn-download-img';
                downloadImgBtn.title = 'Unduh Gambar';
                downloadImgBtn.innerHTML = downloadIconHTML;
                fragment.appendChild(downloadImgBtn);
            }
        
            if (textContentToCopy && textContentToCopy.trim() !== "") {
                const copyBtn = document.createElement('button');
                copyBtn.className = 'message-action-btn copy-message-btn';
                copyBtn.title = 'Salin Pesan';
                copyBtn.innerHTML = copyIconHTML;
                copyBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    navigator.clipboard.writeText(textContentToCopy).then(() => {
                        copyBtn.innerHTML = checkIconHTML;
                        setTimeout(() => { copyBtn.innerHTML = copyIconHTML; }, 1500);
                    }).catch(err => showCustomDialog("Error", "Gagal menyalin pesan.", "alert"));
                });
                fragment.appendChild(copyBtn);
            }
        
            // MODIFIED: Added a condition to NOT add PDF button for images
            if (messageElement.classList.contains('ai-message') && !messageElement.classList.contains('error-message') && !(imageAIData && (imageAIData.imageUrl || imageAIData.processedCanvasDataUrl)) && !messageElement.querySelector('.message-content.bordered-text-loader')) {
                const downloadPdfBtn = document.createElement('button');
                downloadPdfBtn.className = 'message-action-btn download-message-pdf-btn';
                downloadPdfBtn.title = 'Unduh sebagai PDF';
                downloadPdfBtn.innerHTML = downloadPdfIconHTML;
                downloadPdfBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    downloadMessageAsPDF(messageElement.querySelector('.message-content'), `FlabsAI_Response_${messageId.substring(0,8)}`);
                });
                fragment.appendChild(downloadPdfBtn);
            }

            // Common actions for all valid AI messages
            if (messageElement.classList.contains('ai-message') && !messageElement.classList.contains('error-message') && !messageElement.querySelector('.message-content.bordered-text-loader')) {
                const likeBtn = document.createElement('button');
                likeBtn.className = 'message-action-btn like-message-btn';
                likeBtn.title = 'Suka';
                likeBtn.innerHTML = likeIconHTML;
                likeBtn.dataset.messageId = messageId;
                const historyEntryForLike = chatHistory.find(entry => entry.messageId === messageId);
                if (historyEntryForLike && historyEntryForLike.liked === true) {
                    likeBtn.classList.add('active');
                }
                likeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const icon = likeBtn.querySelector('i');
                    if (icon) icon.classList.add('action-activated');
                    setTimeout(() => icon.classList.remove('action-activated'), 400);
                    const isActive = likeBtn.classList.toggle('active');
                    const unlikeBtn = toolbar.querySelector('.unlike-message-btn');
                    if (unlikeBtn) unlikeBtn.classList.remove('active');
                    const historyEntry = chatHistory.find(entry => entry.messageId === messageId);
                    if (historyEntry) {
                        historyEntry.liked = isActive;
                        if(isActive) delete historyEntry.unliked; 
                    }
                    // NEW: Feedback dialog
                    if (isActive) {
                        showCustomDialog("Feedback Diterima", "Terima kasih atas masukan Anda! Ini membantu kami meningkatkan kualitas FlabsAI.", "alert");
                    }
                });
                fragment.appendChild(likeBtn);
        
                const unlikeBtn = document.createElement('button');
                unlikeBtn.className = 'message-action-btn unlike-message-btn';
                unlikeBtn.title = 'Tidak Suka';
                unlikeBtn.innerHTML = unlikeIconHTML;
                unlikeBtn.dataset.messageId = messageId;
                if (historyEntryForLike && historyEntryForLike.unliked === true) {
                    unlikeBtn.classList.add('active');
                }
                unlikeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                    const icon = unlikeBtn.querySelector('i');
                    if (icon) icon.classList.add('action-activated');
                    setTimeout(() => icon.classList.remove('action-activated'), 400);
                    const isActive = unlikeBtn.classList.toggle('active');
                    const likeBtnAssociated = toolbar.querySelector('.like-message-btn');
                    if (likeBtnAssociated) likeBtnAssociated.classList.remove('active');
                     const historyEntry = chatHistory.find(entry => entry.messageId === messageId);
                    if (historyEntry) {
                        historyEntry.unliked = isActive;
                         if(isActive) delete historyEntry.liked; 
                    }
                    // NEW: Feedback dialog
                    if (isActive) {
                        showCustomDialog("Feedback Diterima", "Terima kasih atas masukan Anda! Ini membantu kami meningkatkan kualitas FlabsAI.", "alert");
                    }
                });
                fragment.appendChild(unlikeBtn);
                
                // Don't add restart button to image messages
                if (!(imageAIData && (imageAIData.imageUrl || imageAIData.processedCanvasDataUrl))) {
                    const restartBtn = document.createElement('button');
                    restartBtn.className = 'message-action-btn restart-message-btn';
                    restartBtn.title = 'Ulangi';
                    restartBtn.innerHTML = restartIconHTML;
                    restartBtn.dataset.messageId = messageId;
                    restartBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (aiIsCurrentlyResponding || isGeneratingImage || isProcessingImageClientSide || isVoiceSessionActive || isTextAnimating || isEditing || isWelcomeAnimating) {
                            showCustomDialog("Peringatan", "Harap tunggu proses AI, input suara, atau pengeditan selesai sebelum memulai ulang.", "alert");
                            return;
                        }
                        handleRestartAIMessage(messageId);
                    });
                    fragment.appendChild(restartBtn);
                }
            }
        
            toolbar.appendChild(fragment);
            
            if (!isUserMessage && !isTextAnimating) {
                setTimeout(() => {
                    if (messageElement.isConnected) {
                        messageElement.classList.add('actions-visible');
                    }
                }, 100);
            }
        }

        function animateAiTextResponse(htmlString, targetContentDiv) {
            if (!targetContentDiv || !targetContentDiv.isConnected) {
                console.warn("Target content div for AI animation is not connected to DOM.");
                if (wordAnimationInterval) clearInterval(wordAnimationInterval); 
                isTextAnimating = false; 
                if (!aiIsCurrentlyResponding && !isGeneratingImage && !isProcessingImageClientSide && !isVoiceSessionActive) {
                    setButtonStateForProcessing(false);
                }
                currentAiMessageBubble = null; 
                return;
            }
        
            targetContentDiv.innerHTML = ''; 
            targetContentDiv.style.maxHeight = '55px'; 
            targetContentDiv.style.overflow = 'hidden';
            targetContentDiv.style.transition = 'max-height 0.1s ease-out'; 
        
            const animationQueue = [];
            const parser = new DOMParser();
            const doc = parser.parseFromString(DOMPurify.sanitize(htmlString, domPurifyConfig), 'text/html');
        
            let currentDomParent = targetContentDiv; 
            isTextAnimating = true; 
            setButtonStateForProcessing(true); 
        
            function processNodesRecursive(nodes) {
                if (abortGenerationRequested) return; 
                for (const node of nodes) {
                    if (abortGenerationRequested) return; 

                    if (node.nodeType === Node.ELEMENT_NODE) {
                        if (node.classList && node.classList.contains('artifact-container')) {
                            animationQueue.push(() => {
                                if (abortGenerationRequested || !currentDomParent.isConnected) return; 
                                const clonedArtifact = node.cloneNode(true);
                                clonedArtifact.style.opacity = '0'; 
                                currentDomParent.appendChild(clonedArtifact);
                                requestAnimationFrame(() => { if (!abortGenerationRequested) clonedArtifact.style.opacity = '1'; }); 
                            });
                        } else {
                            const newElement = document.createElement(node.nodeName);
                            Array.from(node.attributes).forEach(attr => {
                                newElement.setAttribute(attr.name, attr.value);
                            });
                            newElement.style.opacity = '0'; 
        
                            animationQueue.push(() => {
                                if (abortGenerationRequested || !currentDomParent.isConnected) return; 
                                currentDomParent.appendChild(newElement);
                                requestAnimationFrame(() => { if (!abortGenerationRequested) newElement.style.opacity = '1'; }); 
                                currentDomParent = newElement; 
                            });
        
                            processNodesRecursive(node.childNodes); 
        
                            animationQueue.push(() => { 
                                if (abortGenerationRequested) return; 
                                if (currentDomParent.parentElement && currentDomParent.parentElement.isConnected) {
                                     currentDomParent = currentDomParent.parentElement;
                                }
                            });
                        }
                    } else if (node.nodeType === Node.TEXT_NODE) {
                        const text = node.textContent;
                        const wordsAndSpaces = text.split(/(\s+)/); 
                        wordsAndSpaces.forEach(part => {
                            if (abortGenerationRequested) return; 
                            if (part.length > 0) { 
                                animationQueue.push(() => {
                                    if (abortGenerationRequested || !currentDomParent.isConnected) return; 
                                    let nodeToAnimate;
                                    if (part.trim().length > 0) { 
                                        const span = document.createElement('span');
                                        span.className = 'ai-word-animated'; 
                                        span.textContent = part;
                                        span.style.opacity = '0'; 
                                        currentDomParent.appendChild(span);
                                        nodeToAnimate = span;
                                    } else { 
                                        currentDomParent.appendChild(document.createTextNode(part));
                                    }
                                    if (nodeToAnimate) {
                                        requestAnimationFrame(() => { if (!abortGenerationRequested) nodeToAnimate.style.opacity = '1'; }); 
                                    }
                                });
                            }
                        });
                    }
                }
            }
        
            processNodesRecursive(doc.body.childNodes);
            if (!abortGenerationRequested) { 
                triggerStaggeredWordAnimation(targetContentDiv, animationQueue);
            } else if (targetContentDiv.isConnected) { 
                 targetContentDiv.style.maxHeight = ''; 
                 targetContentDiv.style.overflow = ''; 
                 isTextAnimating = false; 
                if (!aiIsCurrentlyResponding && !isGeneratingImage && !isProcessingImageClientSide && !isVoiceSessionActive) {
                    setButtonStateForProcessing(false);
                }
                currentAiMessageBubble = null;
            }
        }
        
        
        let wordAnimationInterval = null; 
        function triggerStaggeredWordAnimation(container, animationQueue) {
            if (abortGenerationRequested || !container || !container.isConnected || animationQueue.length === 0) {  
                if (container && container.isConnected) {
                    container.style.maxHeight = ''; 
                    container.style.overflow = ''; 
                }
                isTextAnimating = false; 
                if (!aiIsCurrentlyResponding && !isGeneratingImage && !isProcessingImageClientSide && !isVoiceSessionActive) { 
                    setButtonStateForProcessing(false);
                }
                 if (chatContainer && !userHasInteractedWithScroll) {
                    requestAnimationFrame(() => {
                         if (chatContainer) chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
                    });
                }
                const messageDiv = container.closest('.message');
                if (messageDiv && messageDiv.classList.contains('ai-message')) {
                    const textForCopy = extractTextAndArtifactsForCopy(container.innerHTML, container);
                    addMessageActions(messageDiv, textForCopy, null, messageDiv.dataset.messageId, false);
                }
                return;
            }
        
            let queueIndex = 0;
            const delayIncrement = 25; 
        
            clearInterval(wordAnimationInterval); 
        
            wordAnimationInterval = setInterval(() => {
                if (abortGenerationRequested || !container.isConnected) { 
                    clearInterval(wordAnimationInterval);
                    wordAnimationInterval = null;
                    if (container.isConnected) { 
                        container.style.maxHeight = ''; 
                        container.style.overflow = '';
                    }
                    isTextAnimating = false; 
                    if (!aiIsCurrentlyResponding && !isGeneratingImage && !isProcessingImageClientSide && !isVoiceSessionActive) { 
                        setButtonStateForProcessing(false);
                    }
                    currentAiMessageBubble = null; 
                    return;
                }
        
                if (queueIndex < animationQueue.length) {
                    const animationStep = animationQueue[queueIndex];
                    animationStep(); 
                    
                    if (container.isConnected) { 
                        const currentScrollHeight = container.scrollHeight;
                        const currentClientHeight = container.clientHeight;
                        
                        if (currentScrollHeight > currentClientHeight) {
                             container.style.maxHeight = currentScrollHeight + 'px';
                        }
                        if (chatContainer && !userHasInteractedWithScroll) {
                            requestAnimationFrame(() => {
                                if (chatContainer) chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'auto' }); 
                            });
                        }
                    }
                    queueIndex++;
                } else {
                    clearInterval(wordAnimationInterval);
                    wordAnimationInterval = null;
                    if (container.isConnected) { 
                        container.style.maxHeight = ''; 
                        container.style.overflow = '';
                         if (chatContainer && !userHasInteractedWithScroll) {
                            requestAnimationFrame(() => {
                                 if (chatContainer) chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
                            });
                        }
                    }
                    isTextAnimating = false; 
                    if (!aiIsCurrentlyResponding && !isGeneratingImage && !isProcessingImageClientSide && !isVoiceSessionActive) { 
                        setButtonStateForProcessing(false);
                    }
                    const messageDiv = container.closest('.message');
                    if (messageDiv && messageDiv.classList.contains('ai-message')) {
                        const textForCopy = extractTextAndArtifactsForCopy(container.innerHTML, container);
                        addMessageActions(messageDiv, textForCopy, null, messageDiv.dataset.messageId, false);
                    }
                }
            }, delayIncrement);
        }


        function addMessageToUI(role, contentOrParts, isError = false, userAttachmentsDisplayInfo = null, imageAIData = null, messageIdParam = null, isImageBubble = false) {
            if(!chatContainer) return null;
            const messageId = messageIdParam || `msg-${Date.now()}-${Math.random().toString(16).slice(2)}`;
            const messageDiv = document.createElement("div");
            messageDiv.classList.add("message");
            messageDiv.dataset.messageId = messageId;

            if (role === "user") messageDiv.classList.add("user-message");
            else if (role === "ai" || role === "model") { messageDiv.classList.add("ai-message"); role = "ai"; }
            else if (role === "system-info") messageDiv.classList.add("system-info-message");
            if (isError && role === "ai") messageDiv.classList.add("error-message");

            const contentDiv = document.createElement("div"); contentDiv.classList.add("message-content");
            let textForCopyFromContent = "";
            let mainContentHTML = "";
            
            if (imageAIData) {
                 messageDiv.dataset.imageaidata = JSON.stringify(imageAIData);
                 if (imageAIData.messageId && imageAIData.messageId !== messageId) {
                    messageDiv.dataset.messageId = imageAIData.messageId; 
                 }
            }


            if (role === 'user') {
                if (typeof contentOrParts === 'string' && contentOrParts.trim() !== "") {
                    const tempDiv = document.createElement('div'); tempDiv.textContent = contentOrParts;
                    mainContentHTML += DOMPurify.sanitize(tempDiv.innerHTML.replace(/\n/g, '<br>'), domPurifyConfig);
                    textForCopyFromContent += contentOrParts;
                }
                if (userAttachmentsDisplayInfo && userAttachmentsDisplayInfo.length > 0) {
                    let attachmentsHTML = '<div class="user-sent-attachment-display">';
                    userAttachmentsDisplayInfo.forEach(attInfo => {
                        attachmentsHTML += `<div class="user-sent-attachment-entry" title="${DOMPurify.sanitize(attInfo.name)}">${attInfo.previewHTML}</div>`;
                        if (textForCopyFromContent) textForCopyFromContent += " ";
                        textForCopyFromContent += `[Lampiran ${attInfo.type === 'image' ? 'gambar' : 'dokumen'}: ${attInfo.name}]`;
                    });
                    attachmentsHTML += '</div>';
                    mainContentHTML = attachmentsHTML + (mainContentHTML ? `<br>${mainContentHTML}` : "");
                }
                contentDiv.innerHTML = mainContentHTML || "<p><i>(Pesan kosong)</i></p>";
                messageDiv.appendChild(contentDiv);
                messageDiv.dataset.copyText = textForCopyFromContent;
            } else if (role === 'ai') {
                 let isProcessedImg = false;
                if (imageAIData && imageAIData.processedCanvasDataUrl) isProcessedImg = true;

                if (imageAIData) { 
                    mainContentHTML = `
                        <div class="pollinations-image-display-container ${ (imageAIData.imageUrl || imageAIData.processedCanvasDataUrl) ? '' : 'loading-initial'}">
                            <p class="image-prompt-display"><strong>Prompt:</strong> ${DOMPurify.sanitize(imageAIData.prompt || '')}</p>
                            <div class="image-placeholder">
                                <img src="${imageAIData.imageUrl || ''}" alt="Generated image for: ${DOMPurify.sanitize(imageAIData.prompt || '')}" class="pollinations-generated-image" style="display:${imageAIData.imageUrl && !imageAIData.processedCanvasDataUrl ? 'block' : 'none'};"
                                    onerror="this.alt='Gagal memuat gambar dari Pollinations.'; this.src='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; this.style.display='block';">
                                <canvas class="processed-image-canvas" width="100" height="100" style="display:${imageAIData.processedCanvasDataUrl ? 'block' : 'none'};"></canvas>
                            </div>
                            <div class="image-meta-info">Model: ${DOMPurify.sanitize(imageAIData.model || '')} | Rasio: ${DOMPurify.sanitize(imageAIData.aspectRatio || '')} ${isProcessedImg ? "| Diproses (2x Upscaled)" : ""}</div>
                            <div class="pollinations-support-text">FlabsAI didukung ${isProcessedImg ? "Pollinations & ImageProcessor" : "Pollinations AI"}</div>
                        </div>`;
                    textForCopyFromContent = `[Gambar ${isProcessedImg ? "diproses (2x upscaled)" : "dihasilkan"} oleh AI]\nPrompt: ${imageAIData.prompt || ''}\nModel: ${imageAIData.model || ''}, Rasio: ${imageAIData.aspectRatio || ''}`;
                    contentDiv.innerHTML = DOMPurify.sanitize(mainContentHTML, domPurifyConfig);

                    if (imageAIData.processedCanvasDataUrl) {
                        const canvasElement = contentDiv.querySelector('.processed-image-canvas');
                        if (canvasElement) {
                             const tempImg = new Image();
                             tempImg.onload = () => {
                                 canvasElement.width = tempImg.width;
                                 canvasElement.height = tempImg.height;
                                 canvasElement.getContext('2d').drawImage(tempImg, 0, 0);
                                 canvasElement.style.display = 'block';
                                 contentDiv.querySelector('.pollinations-image-display-container').classList.remove('loading-initial');
                                 addMessageActions(messageDiv, textForCopyFromContent, imageAIData, messageDiv.dataset.messageId, false);
                             }
                             tempImg.onerror = () => {
                                addMessageActions(messageDiv, textForCopyFromContent, null, messageDiv.dataset.messageId, false);
                             }
                             tempImg.src = imageAIData.processedCanvasDataUrl;
                        }
                    } else if (imageAIData.imageUrl) {
                        const imgElement = contentDiv.querySelector('.pollinations-generated-image');
                        if (imgElement) {
                            imgElement.style.display = 'block';
                            imgElement.onload = () => addMessageActions(messageDiv, textForCopyFromContent, imageAIData, messageDiv.dataset.messageId, false);
                            imgElement.onerror = () => addMessageActions(messageDiv, textForCopyFromContent, null, messageDiv.dataset.messageId, false);
                        }
                        contentDiv.querySelector('.pollinations-image-display-container').classList.remove('loading-initial');
                    }
                     messageDiv.appendChild(contentDiv); 
                } else if (typeof contentOrParts === 'string') { 
                    animateAiTextResponse(contentOrParts, contentDiv);
                    textForCopyFromContent = extractTextAndArtifactsForCopy(contentOrParts, null); 
                    messageDiv.appendChild(contentDiv); 
                } else if (Array.isArray(contentOrParts)) { 
                    let htmlOutput = "";
                    contentOrParts.forEach(part => {
                        if (part.text) htmlOutput += DOMPurify.sanitize(part.text, domPurifyConfig); 
                    });
                    animateAiTextResponse(htmlOutput || "<p><i>Respons AI tidak valid.</i></p>", contentDiv);
                    textForCopyFromContent = extractTextAndArtifactsForCopy(htmlOutput || "<p><i>Respons AI tidak valid.</i></p>", null);
                    messageDiv.appendChild(contentDiv); 
                }
            } else if (role === 'system-info') {
                const sanitizedContent = DOMPurify.sanitize(contentOrParts, domPurifyConfig);
                contentDiv.innerHTML = sanitizedContent;
                messageDiv.appendChild(contentDiv);
            }

            const artifactDiv = contentDiv.querySelector('.artifact-container');
            if (artifactDiv) {
                if (contentDiv.querySelector('.code-artifact') || (artifactDiv.classList.contains('code-artifact'))) {
                    artifactDiv.classList.add('code-artifact');
                } else if (contentDiv.querySelector('table') || (artifactDiv.classList.contains('table-artifact'))) {
                    artifactDiv.classList.add('table-artifact');
                }
                const artifactHeaderTitle = artifactDiv.querySelector('.artifact-header .artifact-title');
                if (artifactHeaderTitle) {
                    const clickHint = document.createElement('span');
                    clickHint.className = 'artifact-click-hint';
                    clickHint.textContent = '(klik untuk Melihat)';
                    artifactHeaderTitle.appendChild(clickHint);
                }
            }


            const historyEntry = chatHistory.find(entry => entry.messageId === messageDiv.dataset.messageId);
            if (historyEntry) {
                historyEntry.uiElement = messageDiv;
            }


            chatContainer.appendChild(messageDiv);
            if (role === 'user' || role === 'system-info') {
                scrollToBottom(true);
            } else if (role === 'ai') {
                if (!userHasInteractedWithScroll) scrollToBottom(true);
            }
            return isImageBubble ? messageDiv : contentDiv; 
        }

        function extractTextAndArtifactsForCopy(sanitizedHtml, contentDivElementForDataset) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = sanitizedHtml; 
            let combinedText = "";

            tempDiv.querySelectorAll('.artifact-container').forEach(artifact => {
                const titleElement = artifact.querySelector('.artifact-title');
                let tempTitleHolder = titleElement ? titleElement.cloneNode(true) : null;
                if(tempTitleHolder && tempTitleHolder.querySelector('.artifact-click-hint')) {
                    tempTitleHolder.querySelector('.artifact-click-hint').remove();
                }
                const title = tempTitleHolder ? tempTitleHolder.textContent.trim() : "Artifact";

                const contentElement = artifact.querySelector('.artifact-content');
                let contentText = "";

                if (artifact.classList.contains('code-artifact')) {
                    const codeBlock = contentElement.querySelector('pre code');
                    contentText = codeBlock ? codeBlock.textContent : (contentElement ? contentElement.textContent : "");
                } else if (artifact.classList.contains('table-artifact')) {
                     const table = contentElement.querySelector('table');
                     if(table) {
                        let rows = [];
                        table.querySelectorAll('tr').forEach(tr => {
                            let rowCells = [];
                            tr.querySelectorAll('th, td').forEach(cell => {
                                rowCells.push(`"${cell.textContent.replace(/"/g, '""')}"`);
                            });
                            rows.push(rowCells.join(','));
                        });
                        contentText = rows.join('\n');
                     } else {
                        contentText = contentElement ? contentElement.textContent : "";
                     }
                } else {
                    contentText = contentElement ? contentElement.textContent : "";
                }
                combinedText += `--- ${title} ---\n${contentText.trim()}\n--- Akhir ${title} ---\n\n`;
                artifact.remove(); 
            });

            let mainContentText = "";
            mainContentText = tempDiv.textContent || tempDiv.innerText || "";
            
            combinedText = mainContentText.trim() + (combinedText ? `\n\n${combinedText}` : "");


            if(contentDivElementForDataset) contentDivElementForDataset.dataset.textForCopy = combinedText.trim();
            return combinedText.trim();
        }

        async function handleStopProcessingClick() {
            console.log("Stop button clicked. Aborting all ongoing processes...");
            abortGenerationRequested = true;
            
            if (currentTurnAbortController) {
                currentTurnAbortController.abort('User cancelled the conversation turn.');
            }
            
            if (currentFetchAbortController) {
                currentFetchAbortController.abort("User cancelled fetch.");
            }
            
            if (isProcessingImageClientSide && currentImageOperationId) {
                ignoreWorkerResultForOperationId = currentImageOperationId;
                console.log(`Marked image worker operation ${currentImageOperationId} to be ignored.`);
            }
            
            if (wordAnimationInterval) clearInterval(wordAnimationInterval);
            Object.values(dotAnimationIntervals).forEach(clearInterval);
            dotAnimationIntervals = {};
            
            aiIsCurrentlyResponding = false;
            isGeneratingImage = false;
            isProcessingImageClientSide = false;
            isTextAnimating = false;
            
            const tempThinkingBubble = document.querySelector(`.message[data-op-id="${temporaryThinkingBubbleId}"]`) || document.querySelector(`.message[data-op-id="${currentImageOperationId}"]`);
            if (tempThinkingBubble && tempThinkingBubble.isConnected) {
                const contentDiv = tempThinkingBubble.querySelector('.message-content');
                if (contentDiv) {
                    const parentMessage = contentDiv.closest('.message');
                    if (parentMessage) {
                        parentMessage.classList.remove('ai-message');
                        parentMessage.classList.add('system-info-message');
                        parentMessage.classList.remove('error-message');
                    }
                    contentDiv.innerHTML = `<p>(Dibatalkan oleh pengguna)</p>`;
                    contentDiv.classList.remove('bordered-text-loader');
                }
            } else if (currentAiMessageBubble && currentAiMessageBubble.isConnected) {
                if (!currentAiMessageBubble.innerHTML.includes("Dibatalkan oleh pengguna")) {
                    currentAiMessageBubble.innerHTML += ` <small class='stopped-text'><i>(Dibatalkan oleh pengguna)</i></small>`;
                }
            }
            
            if (isVoiceSessionActive) stopVoiceInputSession(false);
            if (isEditing) cancelEditing();
            
            setButtonStateForProcessing(false);
            
            currentAiMessageBubble = null;
            temporaryThinkingBubbleId = null;
            currentImageOperationId = null;
            currentTurnAbortController = null;
            
            currentTurnUserIntent = { text: null, attachmentsInfo: [], isImageRequest: false, messageId: null };
            
            if (!hasChatStarted) {
                initWelcomeAndQuickActionsSequence();
            }
            
            setTimeout(() => { abortGenerationRequested = false; }, 200);
        }
        
        async function getAIResponseAndHandleCommands(promptPartsForAI, isScrapingFollowUp = false, signal) {
            if (signal.aborted) {
                console.log("getAIResponseAndHandleCommands was called but the turn was already aborted.");
                return;
            }
            
            userHasInteractedWithScroll = false;
            aiIsCurrentlyResponding = true;
            setButtonStateForProcessing(true);
            
            const tempBubbleId = `temp-thinking-${Date.now()}`;
            temporaryThinkingBubbleId = tempBubbleId;
            const hasAttachments = promptPartsForAI.some(p => p.inlineData && p.inlineData.mimeType);
            const baseText = isDeepThinking ? "Sedang Berpikir" : (hasAttachments ? "Memproses File" : "Berpikir");
            
            const tempBubbleContent = addMessageToUI("ai", "", false, null, null, tempBubbleId);
            if (tempBubbleContent) {
                tempBubbleContent.classList.add('bordered-text-loader');
                const tempBubbleMessageDiv = tempBubbleContent.closest('.message');
                if (tempBubbleMessageDiv) tempBubbleMessageDiv.dataset.opId = tempBubbleId;
                startDotAnimation(tempBubbleContent, baseText);
                if (tempBubbleMessageDiv.isConnected && !userHasInteractedWithScroll) scrollToBottom(true);
            }
            
            try {
                if (!genAI) {
                    const geminiReady = await initializeAI();
                    if (!geminiReady) throw new Error("Layanan Gemini tidak dapat diinisialisasi.");
                }
                
                if (signal.aborted) return;
                
                const model = genAI.getGenerativeModel({
                    model: currentGeminiModelName,
                    systemInstruction: getSystemInstructionForChatAI(),
                    safetySettings: [
                        { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
                        { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
                        { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_LOW_AND_ABOVE },
                        { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }
                    ]
                });
                
                let historyForModelContext = chatHistory
                    .filter(entry => !(entry.role === 'model' && (entry.isProcessedImage || entry.imageAIDataForUI)))
                    .map(entry => ({
                        role: entry.role,
                        parts: entry.parts.filter(p => !/ACTION_GENERATE_IMAGE:|ACTION_SCRAPE_URL:/.test(p.text || ''))
                    }));
                
                const chat = model.startChat({ history: historyForModelContext });
                const result = await chat.sendMessage(promptPartsForAI, { signal });
                
                aiIsCurrentlyResponding = false;
                processAndDisplayAIResponse(result, isScrapingFollowUp, promptPartsForAI, signal);
                
            } catch (error) {
                if (abortGenerationRequested || (error.name === 'AbortError')) {
                    console.log("Process was aborted, ignoring subsequent error:", error.message);
                } else {
                    console.error("A non-aborted error occurred:", error);
                    const errorMsgId = `err-msg-${Date.now()}`;
                    addMessageToUI("ai", `<p><b>Oops!</b> Terjadi kesalahan tak terduga: ${error.message}</p>`, true, null, null, errorMsgId);
                }
                
                const tempBubbleToRemove = document.querySelector(`.message[data-op-id="${temporaryThinkingBubbleId}"]`);
                if(tempBubbleToRemove) tempBubbleToRemove.remove();
                
                aiIsCurrentlyResponding = false;
                setButtonStateForProcessing(false);
            }
        }
        
        async function prepareAndSendMessage(isManualInput = true) {
            abortGenerationRequested = false; 
            currentTurnAbortController = new AbortController();
            const signal = currentTurnAbortController.signal;

            const isProcessing = aiIsCurrentlyResponding || isGeneratingImage || isProcessingImageClientSide || isTextAnimating || isVoiceSessionActive || isWelcomeAnimating;
            if (isProcessing && !isEditing) return;
        
            let userMessageText = (userInput ? userInput.value.trim() : "");
            const canSend = userMessageText || attachedFiles.length > 0;
        
            if (!canSend) {
                currentTurnAbortController = null;
                return;
            }
        
            if (isEditing) {
                await submitEdit();
                return;
            }
        
            hasChatStarted = true;
            animateWelcomeAndQuickActionsOut(true);
        
            currentTurnUserIntent.text = userMessageText;
            currentTurnUserIntent.attachmentsInfo = [...attachedFiles];
            currentTurnUserIntent.messageId = `user-msg-${Date.now()}-${Math.random().toString(16).slice(2)}`;
            let attachmentsDisplayInfoForUI = currentTurnUserIntent.attachmentsInfo.map(fileData => ({
                name: fileData.name, type: fileData.type, previewHTML: fileData.previewHTML, dataUrl: fileData.dataUrl
            }));
        
            if (isManualInput) {
                addMessageToUI("user", currentTurnUserIntent.text, false, attachmentsDisplayInfoForUI, null, currentTurnUserIntent.messageId);
                if(userInput) userInput.value = "";
                clearAllAttachments();
                adjustLayout();
                updateSendButtonState();
            }
        
            const geminiContentParts = [];
            let combinedTextForAI = currentTurnUserIntent.text || "";
        
            if (currentTurnUserIntent.attachmentsInfo.length > 0) {
                for (const fileData of currentTurnUserIntent.attachmentsInfo) {
                    try {
                        let preparedData = await prepareFileDataForGemini(fileData);
                        if (!preparedData) continue;
        
                        fileData.base64Data = preparedData.base64Data;
                        fileData.extractedText = preparedData.extractedText;
                        fileData.fileMimeType = preparedData.mimeType;
        
                        if (preparedData.base64Data) {
                             geminiContentParts.push({ inlineData: { mimeType: preparedData.mimeType, data: preparedData.base64Data } });
                        } else if (preparedData.extractedText) {
                            combinedTextForAI = `[Konten dari file terlampir: ${preparedData.name}]\n${preparedData.extractedText}\n[Akhir dari konten file: ${preparedData.name}]\n\n${combinedTextForAI}`;
                        }
                    } catch (e) {
                        showCustomDialog("Error Memproses Lampiran", `Gagal memproses file ${fileData.name || 'lampiran'}: ${e.message}`, "alert");
                        setButtonStateForProcessing(false);
                        currentTurnAbortController = null;
                        return;
                    }
                }
            }
        
            const lowerUserText = combinedTextForAI.toLowerCase();
            const imageKeywords = ["buat gambar", "generate image", "gambar", "lukis", "visualisasikan", "gambarkan", "create image"];
            currentTurnUserIntent.isImageRequest = imageKeywords.some(kw => lowerUserText.includes(kw));
        
            if (currentTurnUserIntent.isImageRequest) {
                const foundForbiddenWord = forbiddenKeywords.find(keyword => lowerUserText.includes(keyword.toLowerCase()));
                if (foundForbiddenWord) {
                    showCustomDialog("Konten Tidak Diizinkan", "Maaf, prompt Anda untuk gambar terdeteksi mengandung kata-kata yang tidak pantas. Harap ubah prompt Anda.", "alert");
                    setButtonStateForProcessing(false);
                    currentTurnAbortController = null;
                    return;
                }
            }
        
            if (combinedTextForAI.trim()) {
                geminiContentParts.unshift({ text: combinedTextForAI.trim() });
            } else if (geminiContentParts.length > 0) {
                let fileNames = currentTurnUserIntent.attachmentsInfo.map(f => f.name).join(', ');
                geminiContentParts.unshift({ text: `Tolong proses file terlampir (${fileNames}).` });
            }
        
            if (geminiContentParts.length === 0) {
                console.warn("No content to send to Gemini.");
                setButtonStateForProcessing(false);
                if (!hasChatStarted) initWelcomeAndQuickActionsSequence();
                currentTurnAbortController = null;
                return;
            }

            getAIResponseAndHandleCommands(geminiContentParts, false, signal);
        }
        
        async function processAndDisplayAIResponse(result, isScrapingFollowUp, originalPromptParts, signal) {
            if (signal.aborted) {
                console.log("processAndDisplayAIResponse called, but signal is aborted. Halting.");
                return;
            }

            const tempBubbleToRemove = document.querySelector(`.message[data-op-id="${temporaryThinkingBubbleId}"]`);
            if(tempBubbleToRemove) tempBubbleToRemove.remove();
            temporaryThinkingBubbleId = null;

            const response = result.response;
            let aiResponseParts = [];
            let aiHtmlText = "";

            if (response && response.candidates && response.candidates[0] && response.candidates[0].content && response.candidates[0].content.parts) {
                aiResponseParts = response.candidates[0].content.parts;
                const textPart = aiResponseParts.find(p => p.text);
                if (textPart) aiHtmlText = textPart.text;
            } else {
                aiHtmlText = "<p><i>Saya tidak dapat memberikan respons saat ini. Coba lagi.</i></p>";
                if (response && response.promptFeedback && response.promptFeedback.blockReason) {
                     aiHtmlText = `<p><i>Respons diblokir: ${response.promptFeedback.blockReason}.</i></p>`;
                }
                aiResponseParts = [{text: aiHtmlText}];
            }

            const scrapeActionRegex = /<p>ACTION_SCRAPE_URL:\s*({.*?})<\/p>/i;
            const imageActionRegex = /<p>ACTION_GENERATE_IMAGE:\s*({.*?})<\/p>/i;
            const scrapeMatch = aiHtmlText.match(scrapeActionRegex);
            const imageMatch = aiHtmlText.match(imageActionRegex);

            if (scrapeMatch && scrapeMatch[1] && !isScrapingFollowUp) {
                 try {
                    const scrapeParams = JSON.parse(scrapeMatch[1]);
                    if (scrapeParams && scrapeParams.url && scrapeParams.original_user_query) {
                        const tempScrapeBubble = addMessageToUI("ai", "", false, null, null, `scrape-${Date.now()}`);
                        tempScrapeBubble.classList.add('bordered-text-loader');
                        startDotAnimation(tempScrapeBubble, `Mengambil dari URL`);
                        const scrapeResult = await fetchUrlContent(scrapeParams.url); 
                        if (tempScrapeBubble && tempScrapeBubble.closest('.message')) tempScrapeBubble.closest('.message').remove();
                        if (signal.aborted) return;
                        let newPromptForAIScraped;
                        if (scrapeResult.success) { 
                            newPromptForAIScraped = `[Scraped content from URL: ${scrapeParams.url}]:\n${scrapeResult.content}\n\n[User's original query regarding this URL]:\n${scrapeParams.original_user_query}`; 
                        } else { 
                            newPromptForAIScraped = `[Failed to scrape content from URL: ${scrapeParams.url}. Error: ${scrapeResult.error}]\n\n[User's original query was]:\n${scrapeParams.original_user_query}\n\n[Inform the user about the failure.]`; 
                        }
                        await getAIResponseAndHandleCommands([{ text: newPromptForAIScraped }], true, signal);
                        return;
                    }
                } catch (e) { /* Fall through to display error */ }
            } else if (imageMatch && imageMatch[1] && currentTurnUserIntent.isImageRequest) {
                try {
                    const imageParams = JSON.parse(imageMatch[1]);
                    if (imageParams && imageParams.prompt) {
                        currentImageAI_AspectRatio = imageParams.aspect_ratio && imageAI_AspectRatios_WithCrop[imageParams.aspect_ratio] ? imageParams.aspect_ratio : "1:1";
                        addMessageToChatHistory('user', originalPromptParts, currentTurnUserIntent.attachmentsInfo, null, false, null, currentTurnUserIntent.messageId, isEditing);
                        await generatePollinationsImage(imageParams.prompt);
                        return;
                    }
                 } catch(e) { /* Fall through to display error */ }
            }
            
            if (currentTurnUserIntent.messageId && !isScrapingFollowUp) {
                addMessageToChatHistory('user', originalPromptParts, currentTurnUserIntent.attachmentsInfo, null, false, null, currentTurnUserIntent.messageId, isEditing);
            }

            const currentMessageIdForAI = `ai-msg-${Date.now()}`;
            const targetContentDiv = addMessageToUI("ai", "", false, null, null, currentMessageIdForAI);
            currentAiMessageBubble = targetContentDiv;
            
            if (response?.promptFeedback?.blockReason) {
                aiHtmlText = `<p><b>Respons tidak dapat ditampilkan:</b> Konten diblokir. (${response.promptFeedback.blockReason})</p>`;
                aiResponseParts = [{text: aiHtmlText}];
                if (targetContentDiv) targetContentDiv.closest('.message').classList.add("error-message");
            }
            
            if (aiHtmlText && aiHtmlText.trim() !== "") {
                animateAiTextResponse(aiHtmlText, targetContentDiv);
                addMessageToChatHistory("model", aiResponseParts, null, null, false, null, currentMessageIdForAI);
            } else {
                 if (targetContentDiv) {
                    targetContentDiv.innerHTML = DOMPurify.sanitize("<p><i>Respons kosong atau tidak dikenal.</i></p>", domPurifyConfig);
                    addMessageActions(targetContentDiv.closest('.message'), "Respons kosong atau tidak dikenal.", null, currentMessageIdForAI, false); 
                 }
                 addMessageToChatHistory("model", [{text: "Respons kosong atau tidak dikenal."}], null, null, false, null, currentMessageIdForAI);
            }

            currentTurnUserIntent = { text: null, attachmentsInfo: [], isImageRequest: false, messageId: null };
            if (hasChatStarted) animateWelcomeAndQuickActionsOut(true);
            setButtonStateForProcessing(false);
        }
        
        async function urlToImageData(url, tempThinkingMessageDiv) {
            if (tempThinkingMessageDiv && tempThinkingMessageDiv.isConnected) {
                const contentDiv = tempThinkingMessageDiv.querySelector('.message-content');
                if (contentDiv) {
                    if (contentDiv.dataset.dotIntervalId) stopDotAnimation(contentDiv.dataset.dotIntervalId);
                    contentDiv.classList.add('bordered-text-loader');
                    startDotAnimation(contentDiv, "Mengunduh Gambar");
                }
            }
            const localFetchAbortController = new AbortController();
            currentFetchAbortController = localFetchAbortController; 


            try {
                 if (abortGenerationRequested) throw new Error("Pembuatan gambar dibatalkan sebelum fetch.");
                const response = await fetch(url, { signal: localFetchAbortController.signal }); 
                if (abortGenerationRequested) throw new Error("Pembuatan gambar dibatalkan selama fetch."); 

                if (!response.ok) {
                    if (url.includes("pollinations.ai") && SCRAPER_PHP_URL && !SCRAPER_PHP_URL.includes("YOUR_SCRAPERWEB_PHP_URL_HERE")) {
                        console.warn(`Fetch CORS gagal untuk ${url}, mencoba via proxy...`);
                        if (abortGenerationRequested) throw new Error("Pembuatan gambar dibatalkan sebelum fetch proxy.");
                        const proxyUrl = `${SCRAPER_PHP_URL}?scrape_url=${encodeURIComponent(url)}&binary=true`;
                        const proxyResponse = await fetch(proxyUrl, { signal: localFetchAbortController.signal }); 
                         if (abortGenerationRequested) throw new Error("Pembuatan gambar dibatalkan selama fetch proxy."); 
                         if (!proxyResponse.ok) { throw new Error(`Gagal mengambil gambar via proxy: HTTP ${proxyResponse.status}`);}
                        const blob = await proxyResponse.blob();
                        if (abortGenerationRequested) throw new Error("Pembuatan gambar dibatalkan setelah blob proxy."); 
                        return blobToImageData(blob);
                    }
                    throw new Error(`Gagal mengambil gambar: HTTP ${response.status}`);
                }
                const blob = await response.blob();
                if (abortGenerationRequested) throw new Error("Pembuatan gambar dibatalkan setelah blob utama."); 
                return blobToImageData(blob);
            } catch (error) {
                 if (error.name === 'AbortError') { 
                    console.log('Image URL fetch aborted by user.');
                     if (tempThinkingMessageDiv && tempThinkingMessageDiv.isConnected && !abortGenerationRequested) {
                        const contentDiv = tempThinkingMessageDiv.querySelector('.message-content');
                        if (contentDiv) {
                            if (contentDiv.dataset.dotIntervalId) stopDotAnimation(contentDiv.dataset.dotIntervalId);
                            contentDiv.innerHTML = DOMPurify.sanitize(`<p><i>Pengunduhan gambar dibatalkan.</i></p>`, domPurifyConfig);
                        }
                    }
                    throw new Error("Pengunduhan gambar dibatalkan."); 
                }
                console.error("Error fetching image for ImageData conversion:", error);
                if (tempThinkingMessageDiv && tempThinkingMessageDiv.isConnected && !abortGenerationRequested) {
                    const contentDiv = tempThinkingMessageDiv.querySelector('.message-content');
                    if (contentDiv) {
                        if (contentDiv.dataset.dotIntervalId) stopDotAnimation(contentDiv.dataset.dotIntervalId);
                        contentDiv.innerHTML = DOMPurify.sanitize(`<p><i>Error mengunduh: ${error.message}</i></p>`, domPurifyConfig);
                    }
                }
                throw error;
            } finally { 
                 if (currentFetchAbortController === localFetchAbortController) {
                    currentFetchAbortController = null;
                }
            }
        }

        async function blobToImageData(blob) {
             if (abortGenerationRequested) throw new Error("Pembuatan gambar dibatalkan sebelum konversi blob."); 
            return new Promise((resolve, reject) => {
                const img = new Image();
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                img.onload = () => {
                    if (abortGenerationRequested) { 
                        URL.revokeObjectURL(img.src);
                        reject(new Error("Pembuatan gambar dibatalkan saat memuat blob."));
                        return;
                    }
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    URL.revokeObjectURL(img.src);
                    resolve(imageData);
                };
                img.onerror = (err) => {
                    URL.revokeObjectURL(img.src);
                    reject(new Error("Gagal memuat blob gambar ke Image elemen." + (err.message ? ` Detail: ${err.message}` : '')));
                };
                img.src = URL.createObjectURL(blob);
            });
        }


        async function generatePollinationsImage(prompt) {
            userHasInteractedWithScroll = false;
            setButtonStateForProcessing(true);
            isGeneratingImage = true;
            currentImageOperationId = `imgOp-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
            ignoreWorkerResultForOperationId = null;
            const currentMessageIdForImageGen = `img-msg-${Date.now()}`;

            const tempBubbleContent = addMessageToUI("ai", "", false, null, null, `temp-img-${currentImageOperationId}`);
            const tempBubbleMessageDiv = tempBubbleContent.closest('.message');
            tempBubbleMessageDiv.dataset.opId = currentImageOperationId;
            tempBubbleContent.classList.add('bordered-text-loader');
            startDotAnimation(tempBubbleContent, "Membuat Gambar");

            if (!userHasInteractedWithScroll) scrollToBottom(true); 

            const selectedRatioConfig = imageAI_AspectRatios_WithCrop[currentImageAI_AspectRatio] || imageAI_AspectRatios_WithCrop["1:1"];
            const originalWidth = selectedRatioConfig.width;
            const originalHeight = selectedRatioConfig.height;
            const upscaleFactor = 2;
            const upscaledWidth = originalWidth * upscaleFactor;
            const upscaledHeight = originalHeight * upscaleFactor;
            const cropPercent = selectedRatioConfig.cropPercent;
            const seed = Math.floor(Math.random() * 100000000);

            let pollingationsApiUrl = `${POLLINATIONS_BASE_URL}${encodeURIComponent(prompt)}`;
            const queryParams = [];
            queryParams.push(`width=${originalWidth}`);
            queryParams.push(`height=${originalHeight}`);
            queryParams.push(`seed=${seed}`);
            queryParams.push(`model=${encodeURIComponent(currentImageAI_PollinationsModel)}`);

            if (queryParams.length > 0) pollingationsApiUrl += '?' + queryParams.join('&');

            console.log("Pollinations API URL (requesting original size):", pollingationsApiUrl, "OpID:", currentImageOperationId);

            const imageGenerationDataForWorker = {
                prompt: prompt,
                imageUrl: pollingationsApiUrl,
                model: currentImageAI_PollinationsModel,
                aspectRatio: currentImageAI_AspectRatio,
                messageId: currentMessageIdForImageGen
            };
            
            const minFetchDelayPromise = new Promise(resolve => setTimeout(resolve, MIN_IMAGE_LOADING_DISPLAY_MS));
            let imageDataFromPollinations;

            try {
                addMessageToChatHistory(
                    'user', currentTurnUserIntent.text, currentTurnUserIntent.attachmentsInfo, 
                    null, false, null, currentTurnUserIntent.messageId, false
                );

                imageDataFromPollinations = await urlToImageData(pollingationsApiUrl, tempBubbleMessageDiv); 
                await minFetchDelayPromise;

                if (abortGenerationRequested) { 
                    throw new Error("Pembuatan gambar dibatalkan setelah fetch atau selama delay.");
                }

                isGeneratingImage = false; 

                if (imageDataFromPollinations) {
                    isProcessingImageClientSide = true;
                    setButtonStateForProcessing(true);
                     if (tempBubbleContent && tempBubbleContent.isConnected) {
                        if (tempBubbleContent.dataset.dotIntervalId) stopDotAnimation(tempBubbleContent.dataset.dotIntervalId);
                        startDotAnimation(tempBubbleContent, "Memproses Gambar");
                    }

                    const workerParams = {
                        ...imageEnhancementParams,
                        cropPercent: cropPercent
                    };

                    imageProcessorWorker.postMessage({
                        imageData: imageDataFromPollinations,
                        params: workerParams,
                        newWidth: upscaledWidth,
                        newHeight: upscaledHeight,
                        originalPollinationsData: imageGenerationDataForWorker,
                        operationId: currentImageOperationId
                    });

                } else {
                    console.error("Tidak ada ImageData yang diterima dari Pollinations untuk diproses. OpID:", currentImageOperationId);
                     if (tempBubbleContent && tempBubbleContent.isConnected) {
                        if (tempBubbleContent.dataset.dotIntervalId) stopDotAnimation(tempBubbleContent.dataset.dotIntervalId);
                        tempBubbleContent.innerHTML = DOMPurify.sanitize(`<p><i>Gagal mendapatkan data gambar dari Pollinations untuk diproses.</i></p>`, domPurifyConfig);
                        tempBubbleMessageDiv.classList.add("error-message");
                        addMessageActions(tempBubbleMessageDiv, "Gagal mendapatkan data gambar.", null, currentMessageIdForImageGen, false);
                    }
                    isProcessingImageClientSide = false;
                    setButtonStateForProcessing(false);
                    
                    addMessageToChatHistory("model", [{ text: "Gagal memuat gambar dari Pollinations untuk diproses." }], null, null, false, null, `err-${currentMessageIdForImageGen}`);

                    currentTurnUserIntent = { text: null, attachmentsInfo: [], isImageRequest: false, messageId: null };
                    currentImageOperationId = null;
                    if (hasChatStarted) animateWelcomeAndQuickActionsOut(true);
                }

            } catch (error) {
                console.error("Error saat generatePollinationsImage (setelah fetch attempt). OpID:", currentImageOperationId, error);
                isGeneratingImage = false;
                isProcessingImageClientSide = false;

                if (tempBubbleContent && tempBubbleContent.isConnected) {
                     if (tempBubbleContent.dataset.dotIntervalId) stopDotAnimation(tempBubbleContent.dataset.dotIntervalId);
                     if (error.message.includes("dibatalkan")) {
                        tempBubbleContent.innerHTML = DOMPurify.sanitize("<p><i>Pembuatan gambar dibatalkan.</i></p>", domPurifyConfig);
                     } else {
                        tempBubbleContent.innerHTML = DOMPurify.sanitize(`<p><i>Error: ${error.message}</i></p>`, domPurifyConfig);
                        tempBubbleMessageDiv.classList.add("error-message");
                     }
                    addMessageActions(tempBubbleMessageDiv, `Error: ${error.message}`, null, currentMessageIdForImageGen, false);
                }
                setButtonStateForProcessing(false);
                addMessageToChatHistory("model", [{ text: `Error memproses permintaan gambar: ${error.message}` }], null, null, false, null, `err-${currentMessageIdForImageGen}`);
                currentTurnUserIntent = { text: null, attachmentsInfo: [], isImageRequest: false, messageId: null };
                currentImageOperationId = null;
                 if (hasChatStarted) animateWelcomeAndQuickActionsOut(true);
            }
        }
        
        async function startApp() {
            loadChatSessions();

            const aiServiceReady = await initializeAI();

            if (aiServiceReady) {
                setButtonStateForProcessing(false);
                currentAiMessageBubble = null;
            } else {
                 disableChat();
            }
        }

        function applyPermanentDarkMode() {
            const htmlEl = document.documentElement;
            const bodyEl = document.body;

            // Always apply dark mode
            bodyEl.classList.add('dark-mode');
            
            // Create and set the theme-color meta tag for dark mode
            const themeColorMeta = document.createElement('meta');
            themeColorMeta.name = 'theme-color';
            themeColorMeta.setAttribute('content', '#0c0c0e'); // Dark mode background color
            document.head.appendChild(themeColorMeta);

            // Set initial background colors
            const newBgColor = getComputedStyle(bodyEl).getPropertyValue('--bg-color').trim();
            htmlEl.style.backgroundColor = newBgColor;
            bodyEl.style.backgroundColor = newBgColor;
            if (appLayoutContainer) {
                appLayoutContainer.style.backgroundColor = newBgColor;
            }
        }


        function handleArtifactAction(action, artifactContainerElement, buttonClicked) {
            if (!artifactContainerElement) return;
            const artifactContentElement = artifactContainerElement.querySelector('.artifact-content');
            const artifactTitleElement = artifactContainerElement.querySelector('.artifact-title');
             let title = "Artifact";
             if(artifactTitleElement) {
                const tempTitleClone = artifactTitleElement.cloneNode(true);
                const hint = tempTitleClone.querySelector('.artifact-click-hint');
                if (hint) hint.remove();
                title = tempTitleClone.textContent.trim();
             }

            const isCodeArtifact = artifactContainerElement.classList.contains('code-artifact');
            const isTableArtifact = artifactContainerElement.classList.contains('table-artifact');
            const isHtmlArtifact = isCodeArtifact && title.toLowerCase().includes("html");


            if (action === 'expand') {
                openArtifactViewer(title, artifactContentElement.innerHTML, isCodeArtifact, isTableArtifact, isHtmlArtifact);
            } else if (action === 'copy') {
                let textToCopy = "";
                if (isCodeArtifact) {
                    const codeBlock = artifactContentElement.querySelector('pre code');
                    textToCopy = codeBlock ? codeBlock.textContent : artifactContentElement.textContent;
                } else if (isTableArtifact) {
                    textToCopy = tableToCSV(artifactContentElement.querySelector('table'));
                } else {
                    textToCopy = artifactContentElement.textContent;
                }
                navigator.clipboard.writeText(textToCopy).then(() => {
                    const originalHTML = buttonClicked.innerHTML;
                    buttonClicked.innerHTML = checkIconHTML;
                    setTimeout(() => { buttonClicked.innerHTML = copyIconHTML; }, 1500);
                }).catch(err => showCustomDialog("Error", "Gagal menyalin artifact.", "alert"));
            } else if (action === 'download') {
                downloadArtifact(title, artifactContentElement, isCodeArtifact, isTableArtifact);
            }
        }

        function tableToCSV(tableElement) {
            if (!tableElement) return "";
            let csv = [];
            const rows = tableElement.querySelectorAll("tr");
            for (const row of rows) {
                const cols = row.querySelectorAll("td, th");
                const csvRow = [];
                for (const col of cols) {
                    let data = col.innerText.replace(/"/g, '""');
                    if (data.includes(",")) data = `"${data}"`;
                    csvRow.push(data);
                }
                csv.push(csvRow.join(","));
            }
            return csv.join("\n");
        }

        function determineArtifactFileExtension(title, isCode, isTable) {
            if (isTable) return ".csv";
            if (isCode) {
                const lowerTitle = title.toLowerCase();
                if (lowerTitle.includes("python")) return ".py";
                if (lowerTitle.includes("javascript") || lowerTitle.includes("js")) return ".js";
                if (lowerTitle.includes("html")) return ".html";
                if (lowerTitle.includes("css")) return ".css";
                if (lowerTitle.includes("java")) return ".java";
                if (lowerTitle.includes("json")) return ".json";
            }
            return ".txt";
        }

        function downloadArtifact(title, contentElement, isCode, isTable, fromModal = false, isHtmlSourceForModal = false) {
            let dataToDownload;
            const fileExtension = determineArtifactFileExtension(title, isCode, isTable);
            let mimeType = "text/plain;charset=utf-8";

            if (isTable) {
                 const tableEl = fromModal ? contentElement.querySelector('table') : contentElement.querySelector('.table-artifact-viewer-content table, .artifact-content table');
                dataToDownload = tableToCSV(tableEl);
                mimeType = "text/csv;charset=utf-8";
            } else if (isCode) {
                 const codeBlock = fromModal ? contentElement.querySelector('pre code') : contentElement.querySelector('.code-artifact-viewer-content pre code, .artifact-content pre code');
                dataToDownload = codeBlock ? codeBlock.textContent : contentElement.textContent;
                 if (fileExtension === ".html") mimeType = "text/html;charset=utf-8";
                 else if (fileExtension === ".js") mimeType = "text/javascript;charset=utf-8";
                 else if (fileExtension === ".css") mimeType = "text/css;charset=utf-8";
            } else {
                dataToDownload = contentElement.textContent;
            }


            const safeFilenameBase = title.substring(0, 50).replace(/[^a-z0-9 _-]/gi, '_').toLowerCase();
            const filename = `${safeFilenameBase || "artifact"}${fileExtension}`;

            const blob = new Blob([dataToDownload], { type: mimeType });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);

            if (fromModal && artifactViewerDownloadBtn) {
                const originalBtnContent = artifactViewerDownloadBtn.innerHTML;
                const checkHTML = checkIconHTML;
                artifactViewerDownloadBtn.innerHTML = DOMPurify.sanitize(checkHTML, domPurifyConfig);
                artifactViewerDownloadBtn.title = "Terunduh";
                setTimeout(() => {
                    artifactViewerDownloadBtn.innerHTML = DOMPurify.sanitize(downloadIconHTML, domPurifyConfig);
                    artifactViewerDownloadBtn.title = "Unduh Artifact";
                }, 2000);
            }
        }
        
        function openArtifactViewer(title, contentHTML, isCode, isTable, isHtml) {
            if (!artifactViewerModal || !artifactViewerModalBody || !artifactViewerCopyBtn || !artifactViewerDownloadBtn) return;
            
            if (artifactViewerTitle) artifactViewerTitle.textContent = title;

            let displayContent = "";
            if (isCode) { 
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = contentHTML; 
                const codeText = tempDiv.querySelector('pre code') ? tempDiv.querySelector('pre code').textContent : tempDiv.textContent;
                displayContent = `<div class="code-artifact-viewer-content"><pre><code>${DOMPurify.sanitize(codeText, {...domPurifyConfig, ALLOWED_TAGS:[]})}</code></pre></div>`;
            } else if (isTable) {
                displayContent = `<div class="table-artifact-viewer-content">${DOMPurify.sanitize(contentHTML, domPurifyConfig)}</div>`;
            } else {
                displayContent = DOMPurify.sanitize(contentHTML, domPurifyConfig);
            }
            artifactViewerModalBody.innerHTML = displayContent;

            artifactViewerCopyBtn.innerHTML = DOMPurify.sanitize(copyIconHTML, domPurifyConfig);
            artifactViewerCopyBtn.title = "Salin Konten";
            artifactViewerDownloadBtn.innerHTML = DOMPurify.sanitize(downloadIconHTML, domPurifyConfig);
            artifactViewerDownloadBtn.title = "Unduh Artifact";

            artifactViewerCopyBtn.onclick = () => {
                let textToCopy;
                if (isCode) {
                    const codeBlock = artifactViewerModalBody.querySelector('.code-artifact-viewer-content pre code');
                    textToCopy = codeBlock ? codeBlock.textContent : artifactViewerModalBody.textContent;
                } else if (isTable) {
                    textToCopy = tableToCSV(artifactViewerModalBody.querySelector('.table-artifact-viewer-content table'));
                } else {
                    textToCopy = artifactViewerModalBody.textContent;
                }

                navigator.clipboard.writeText(textToCopy).then(() => {
                    const originalHTML = artifactViewerCopyBtn.innerHTML;
                    const checkHTML = checkIconHTML;
                     artifactViewerCopyBtn.innerHTML = DOMPurify.sanitize(checkHTML, domPurifyConfig);
                     artifactViewerCopyBtn.title = "Tersalin";
                    setTimeout(() => {
                        artifactViewerCopyBtn.innerHTML = DOMPurify.sanitize(copyIconHTML, domPurifyConfig);
                        artifactViewerCopyBtn.title = "Salin Konten";
                    }, 1500);
                }).catch(err => showCustomDialog("Error", "Gagal menyalin artifact.", "alert"));
            };

            artifactViewerDownloadBtn.onclick = () => {
                downloadArtifact(title, artifactViewerModalBody, isCode, isTable, true);
            };

            openModal(artifactViewerModal);
        }

        async function downloadImageWithFetch(imageUrlOrDataUrl, promptForFilename, isProcessedCanvas = false) {
            const localFetchAbortController = new AbortController();
            currentFetchAbortController = localFetchAbortController;

            try {
                const safeFilenameBase = (promptForFilename || "generated_image").substring(0, 40).replace(/[^a-z0-9]/gi, '_').toLowerCase();
                let blob;

                if (isProcessedCanvas && imageUrlOrDataUrl.startsWith('data:image/')) {
                    const fetchRes = await fetch(imageUrlOrDataUrl, { signal: localFetchAbortController.signal }); 
                    if (abortGenerationRequested) throw new Error("Unduhan gambar dibatalkan."); 
                    blob = await fetchRes.blob();
                    if (abortGenerationRequested) throw new Error("Unduhan gambar dibatalkan."); 
                } else if (!isProcessedCanvas && typeof imageUrlOrDataUrl === 'string' && (imageUrlOrDataUrl.startsWith('http') || imageUrlOrDataUrl.startsWith('//'))) {
                    let actualUrlToFetch = imageUrlOrDataUrl;
                    if(actualUrlToFetch.startsWith('//')) actualUrlToFetch = 'https:' + actualUrlToFetch;

                    const response = await fetch(actualUrlToFetch, { mode: 'cors', signal: localFetchAbortController.signal }); 
                    if (abortGenerationRequested) throw new Error("Unduhan gambar dibatalkan."); 

                    if (!response.ok) {
                        if (actualUrlToFetch.includes("pollinations.ai") && SCRAPER_PHP_URL && !SCRAPER_PHP_URL.includes("YOUR_SCRAPERWEB_PHP_URL_HERE")) {
                            console.warn(`Fetch CORS gagal untuk ${actualUrlToFetch}, mencoba via proxy...`);
                            const proxyUrl = `${SCRAPER_PHP_URL}?scrape_url=${encodeURIComponent(actualUrlToFetch)}&binary=true`;
                            const proxyResponse = await fetch(proxyUrl, { signal: localFetchAbortController.signal }); 
                            if (abortGenerationRequested) throw new Error("Unduhan gambar dibatalkan."); 
                            if (!proxyResponse.ok) {
                                throw new Error(`Gagal mengambil gambar via proxy: HTTP ${proxyResponse.status}`);
                            }
                            blob = await proxyResponse.blob();
                            if (abortGenerationRequested) throw new Error("Unduhan gambar dibatalkan."); 
                        } else {
                            throw new Error(`Gagal mengambil gambar: HTTP ${response.status}`);
                        }
                    } else {
                         blob = await response.blob();
                         if (abortGenerationRequested) throw new Error("Unduhan gambar dibatalkan."); 
                    }
                } else {
                    throw new Error("URL gambar tidak valid atau tipe tidak dikenali.");
                }

                processAndDownloadBlob(blob, safeFilenameBase);

            } catch (error) {
                 if (error.name === 'AbortError' || error.message.includes("dibatalkan")) { 
                    console.log('Image download fetch aborted by user.');
                } else {
                    console.error("Error downloading image:", error);
                    showCustomDialog("Error Mengunduh", `Gagal mengunduh gambar: ${error.message}`, "alert");
                }
            } finally { 
                 if (currentFetchAbortController === localFetchAbortController) {
                    currentFetchAbortController = null;
                }
            }
        }

        function processAndDownloadBlob(blob, safeFilenameBase) {
            if (abortGenerationRequested) return;
            let extension = 'png';
            const type = blob.type;
            if (type && type.startsWith('image/')) {
                const subType = type.split('/')[1];
                if (['jpeg', 'jpg', 'webp', 'gif', 'png'].includes(subType)) {
                    extension = subType === 'jpeg' ? 'jpg' : subType;
                }
            }
            const filename = `${safeFilenameBase}.${extension}`;
            const linkForDownload = document.createElement('a');
            linkForDownload.href = URL.createObjectURL(blob);
            linkForDownload.download = filename;
            document.body.appendChild(linkForDownload);
            linkForDownload.click();
            document.body.removeChild(linkForDownload);
            URL.revokeObjectURL(linkForDownload.href);
        }

        async function downloadMessageAsPDF(messageContentElement, filenameBase = "FlabsAI_Message") {
            if (!messageContentElement || !messageContentElement.isConnected) {
                showCustomDialog("Error", "Tidak ada konten pesan untuk diunduh.", "alert");
                return;
            }

            const loadingMessageId = `pdf-download-loading-${Date.now()}`;
            const tempMsgElementContainer = addMessageToUI("system-info", `<p id="${loadingMessageId}">Mempersiapkan PDF...</p>`);
            const tempMsgElement = tempMsgElementContainer ? tempMsgElementContainer.querySelector(`#${loadingMessageId}`) : null;


            try {
                const clone = messageContentElement.cloneNode(true);
                
                clone.style.position = 'absolute';
                clone.style.left = '-9999px';
                clone.style.width = '700px'; 
                clone.style.padding = '20px';
                clone.style.backgroundColor = 'white'; 
                clone.style.color = 'black'; 
                
                clone.querySelectorAll('.message-actions-toolbar, .edit-controls, .artifact-click-hint').forEach(el => el.remove());
                clone.querySelectorAll('button').forEach(btn => btn.style.display = 'none'); 

                clone.querySelectorAll('.artifact-content').forEach(ac => {
                    ac.style.maxHeight = 'none';
                    ac.style.overflow = 'visible';
                });
                
                document.body.appendChild(clone);

                const canvas = await html2canvas(clone, {
                    scale: 2, 
                    useCORS: true, 
                    backgroundColor: '#ffffff',
                    onclone: (doc) => { 
                        doc.body.classList.remove('dark-mode');
                        doc.documentElement.classList.remove('dark-mode');
                        const clonedAppLayout = doc.getElementById('app-layout-container');
                        if(clonedAppLayout) clonedAppLayout.style.backgroundColor = 'white';
                    }
                });
                
                document.body.removeChild(clone); 

                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'pt',
                    format: 'a4'
                });

                const pdfWidth = pdf.internal.pageSize.getWidth();
                const pdfHeight = pdf.internal.pageSize.getHeight();
                const imgProps = pdf.getImageProperties(imgData);
                const imgWidth = pdfWidth - 40; 
                const imgHeight = (imgProps.height * imgWidth) / imgProps.width;
                
                let heightLeft = imgHeight;
                let position = 20; 

                pdf.addImage(imgData, 'PNG', 20, position, imgWidth, imgHeight);
                heightLeft -= (pdfHeight - 40); 

                while (heightLeft > 0) {
                    position = heightLeft - imgHeight; 
                    pdf.addPage();
                    pdf.addImage(imgData, 'PNG', 20, position, imgWidth, imgHeight);
                    heightLeft -= (pdfHeight - 40);
                }
                
                pdf.save(`${filenameBase}.pdf`);

                if (tempMsgElement && tempMsgElement.isConnected && tempMsgElement.closest('.message')) {
                    tempMsgElement.innerHTML = DOMPurify.sanitize("<p>Unduhan PDF dimulai.</p>", domPurifyConfig);
                    setTimeout(() => {
                        if (tempMsgElement && tempMsgElement.isConnected && tempMsgElement.closest('.message')) tempMsgElement.closest('.message').remove();
                    }, 3000);
                }

            } catch (error) {
                console.error("Error generating PDF:", error);
                showCustomDialog("Error PDF", `Gagal membuat PDF: ${error.message}`, "alert");
                if (tempMsgElement && tempMsgElement.isConnected && tempMsgElement.closest('.message')) {
                    tempMsgElement.innerHTML = DOMPurify.sanitize(`<p>Gagal membuat PDF: ${error.message}</p>`, domPurifyConfig);
                }
            }
        }

        function initializeCustomSelect() {
            if (!customReportCategoryContainer) return;
            const trigger = customReportCategoryContainer.querySelector('.custom-select-trigger');
            const optionsContainer = customReportCategoryContainer.querySelector('.custom-select-options');
            const originalSelect = document.getElementById('report-category');

            optionsContainer.innerHTML = '';
            Array.from(originalSelect.options).forEach(option => {
                const customOption = document.createElement('div');
                customOption.classList.add('custom-select-option');
                customOption.textContent = option.textContent;
                customOption.dataset.value = option.value;
                if (option.selected) {
                    trigger.textContent = option.textContent;
                    customOption.classList.add('selected');
                }
                optionsContainer.appendChild(customOption);

                customOption.addEventListener('click', () => {
                    optionsContainer.querySelectorAll('.custom-select-option').forEach(opt => opt.classList.remove('selected'));
                    customOption.classList.add('selected');
                    trigger.textContent = customOption.textContent;
                    originalSelect.value = customOption.dataset.value;
                    customReportCategoryContainer.classList.remove('open');
                });
            });

            trigger.addEventListener('click', () => {
                customReportCategoryContainer.classList.toggle('open');
            });
        }


        function initializeNewVoiceSystem() {
            const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognitionAPI) {
                speechRecognition = new SpeechRecognitionAPI();
                speechRecognition.lang = 'id-ID';
                speechRecognition.continuous = false;
                speechRecognition.interimResults = true;

                speechRecognition.onresult = (event) => {
                    if (!isVoiceSessionActive) return;

                    let interimTranscript = '';
                    let newFinalTranscriptPortion = '';
                    
                    let targetText = isEditing ? "" : currentSessionAccumulatedText;

                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            if (isEditing) {
                                targetText += transcript.trim() + ' ';
                            } else {
                                newFinalTranscriptPortion += transcript.trim() + ' ';
                            }
                        } else {
                            interimTranscript += transcript;
                        }
                    }

                    if (isEditing) {
                        userInput.value = (preExistingInputText ? preExistingInputText + " " : "") + targetText.trim() + (interimTranscript ? " " + interimTranscript.trim() : "");
                    } else {
                         if (newFinalTranscriptPortion) {
                            currentSessionAccumulatedText += newFinalTranscriptPortion;
                        }
                        userInput.value = (preExistingInputText ? preExistingInputText + " " : "") + currentSessionAccumulatedText.trim() + (interimTranscript ? " " + interimTranscript.trim() : "");
                    }
                    
                    userInput.value = userInput.value.replace(/\s+/g, ' ').trim();

                    adjustLayout();
                    updateSendButtonState();
                };

                speechRecognition.onend = () => {
                    if (isVoiceSessionActive) {
                        console.log("SpeechRecognition ended, restarting for loop...");
                        try {
                           if (!document.hidden && isVoiceSessionActive) {
                                speechRecognition.start();
                           } else if (document.hidden) {
                               console.log("Tab is not active, not restarting speech recognition immediately.");
                               stopVoiceInputSession(true);
                           }
                        } catch (e) {
                            console.error("Error restarting speechRecognition in onend:", e);
                            if (e.name === 'NotAllowedError' || e.name === 'NoSpeechError' && lastRecognitionError === 'no-speech') {
                                stopVoiceInputSession(false);
                                showCustomDialog("Error Input Suara", `Izin mikrofon mungkin ditolak atau tidak ada suara terdeteksi. Silakan periksa pengaturan browser Anda (biasanya di Pengaturan Situs -> Mikrofon) dan pastikan FlabsAI diizinkan. Sesi dihentikan.`, "alert");
                            } else if (e.name === 'not-allowed' || e.name === 'service-not-allowed') {
                                stopVoiceInputSession(false);
                                showCustomDialog("Error Input Suara", "Izin mikrofon ditolak atau layanan tidak tersedia. Pastikan mikrofon diizinkan untuk situs ini di pengaturan browser Anda. Sesi dihentikan.", "alert");
                            }
                        }
                    } else {
                        console.log("SpeechRecognition ended, voice session is NOT active or tab became hidden.");
                        resetVoiceInputSystem();
                    }
                    lastRecognitionError = null;
                };

                speechRecognition.onerror = (event) => {
                    console.error('Speech Recognition Error:', event.error, event.message);
                    lastRecognitionError = event.error;

                    if (isVoiceSessionActive) {
                        let userMessage = `Error input suara: ${event.error}.`;
                         if (voiceTimerDisplayElement) voiceTimerDisplayElement.textContent = `Error: ${event.error}`;

                        if (event.error === 'no-speech') {
                            userMessage = "Tidak ada suara terdeteksi. Masih mendengarkan...";
                            if (voiceTimerDisplayElement) voiceTimerDisplayElement.textContent = "Tidak ada suara...";
                        } else if (event.error === 'audio-capture') {
                            userMessage = "Gagal menangkap audio. Periksa mikrofon Anda.";
                            if (voiceTimerDisplayElement) voiceTimerDisplayElement.textContent = "Error Audio";
                            showCustomDialog("Error Mikrofon", userMessage + " Pastikan mikrofon terhubung dan diizinkan oleh sistem operasi.", "alert");
                            stopVoiceInputSession(false);
                        } else if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                            userMessage = "Izin mikrofon ditolak atau layanan tidak tersedia. Aktifkan di pengaturan browser Anda (biasanya di Pengaturan Situs -> Mikrofon) dan pastikan FlabsAI diizinkan.";
                            if (voiceTimerDisplayElement) voiceTimerDisplayElement.textContent = "Izin Ditolak";
                            showCustomDialog("Izin Mikrofon Ditolak", userMessage, "alert");
                            stopVoiceInputSession(false);
                        } else if (event.error === 'network') {
                            userMessage = "Masalah jaringan saat input suara.";
                            if (voiceTimerDisplayElement) voiceTimerDisplayElement.textContent = "Jaringan Error";
                        } else if (event.error === 'aborted'){
                            console.log("Speech recognition aborted, likely by user or stop().");
                        } else {
                            console.warn("Unhandled speech error, allowing onend to attempt restart:", event.error);
                        }
                    }
                };

                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && isVoiceSessionActive && speechRecognition) {
                        console.log("Tab became hidden during voice session. Stopping recognition.");
                        isVoiceSessionActive = false;
                        try {
                           speechRecognition.stop();
                        } catch(e){
                           console.warn("Error stopping speech recognition on visibility change:", e);
                           resetVoiceInputSystem();
                        }
                    } else if (!document.hidden && !isVoiceSessionActive && micBtn && micBtn.classList.contains('active')) {
                        resetVoiceInputSystem();
                    }
                });

                console.log("New Voice Input System Initialized with visibility handling.");
            } else {
                console.warn("Speech Recognition API not supported in this browser.");
                if (micBtn) micBtn.style.display = 'none';
                showCustomDialog("Browser Tidak Mendukung", "Maaf, browser Anda tidak mendukung fitur input suara.", "alert");
            }
        }

        async function handleMicClickNew() {
            if (isVoiceSessionActive) {
                handleVoiceFinishClick();
                return;
            }

            if ((aiIsCurrentlyResponding || isGeneratingImage || isProcessingImageClientSide || isTextAnimating || isWelcomeAnimating) && !isEditing) {
                showCustomDialog("Peringatan", "Harap tunggu proses AI selesai sebelum memulai input suara.", "alert");
                return;
            }

            startVoiceInputSession();
        }

        function startVoiceInputSession() {
            if (!speechRecognition) {
                showCustomDialog("Error", "Input suara tidak didukung browser ini atau belum diinisialisasi.", "alert");
                return;
            }
            if (isVoiceSessionActive) return;

            isVoiceSessionActive = true;
            preExistingInputText = userInput.value.trim();
            currentSessionAccumulatedText = "";
            lastRecognitionError = null;

            showVoiceSessionUI();
            startVoiceTimerDisplay();
            setButtonStateForProcessing(true);

            try {
                speechRecognition.start();
                console.log("SpeechRecognition session started. Waiting for permission prompt if needed.");
            } catch (e) {
                console.error("Error starting SpeechRecognition:", e);
                 if (e.name === 'NotAllowedError' || e.name === 'SecurityError' || e.name === 'InvalidStateError') {
                    showCustomDialog("Error Input Suara", "Gagal memulai input suara. Pastikan izin mikrofon telah diberikan di pengaturan browser Anda. Error: " + e.message, "alert");
                } else {
                    showCustomDialog("Error Input Suara", `Gagal memulai input suara: ${e.message}`, "alert");
                }
                resetVoiceInputSystem();
            }
        }

        function stopVoiceInputSession(isAcceptedByUser) {
            const wasActive = isVoiceSessionActive;
            isVoiceSessionActive = false; 

            if (speechRecognition) {
                 try {
                    speechRecognition.stop(); 
                } catch (e) {
                     console.warn("Error stopping speech recognition in stopVoiceInputSession:", e);
                     resetVoiceInputSystem(); 
                }
            } else {
                resetVoiceInputSystem();
            }
        }

        function handleVoiceCancelClick() {
            if (!isVoiceSessionActive) return;
            console.log("Voice input CANCELLED by user.");
            stopVoiceInputSession(false); 
            userInput.value = preExistingInputText; 
            currentSessionAccumulatedText = "";
            resetVoiceInputSystem();
        }

        function handleVoiceFinishClick() {
            if (!isVoiceSessionActive) return;
            console.log("Voice input FINISHED by user.");
            stopVoiceInputSession(true); 
            if (isEditing) {
                // The value is already in userInput from onresult
            } else {
                userInput.value = (preExistingInputText ? preExistingInputText + " " : "") + currentSessionAccumulatedText.trim();
                userInput.value = userInput.value.replace(/\s+/g, ' ').trim();
            }
            resetVoiceInputSystem();
        }

        function resetVoiceInputSystem() {
            console.log("Resetting voice input system UI and state.");
            isVoiceSessionActive = false; 
            hideVoiceSessionUI();
            stopVoiceTimerDisplay();

            preExistingInputText = "";
            currentSessionAccumulatedText = "";
            lastRecognitionError = null;

            setButtonStateForProcessing(false);
            updateSendButtonState();
            adjustLayout();
            if (userInput && !isAnyModalOpen()) { 
                 userInput.focus();
            }
        }

        function startVoiceTimerDisplay() {
            voiceSessionStartTime = Date.now();
            if (voiceTimerDisplayElement) voiceTimerDisplayElement.textContent = '0:00';
            clearInterval(voiceTimerInterval);
            voiceTimerInterval = setInterval(() => {
                if (!isVoiceSessionActive) {
                    clearInterval(voiceTimerInterval);
                    return;
                }
                const elapsedTime = Math.floor((Date.now() - voiceSessionStartTime) / 1000);
                const minutes = Math.floor(elapsedTime / 60);
                const seconds = elapsedTime % 60;
                if (voiceTimerDisplayElement && !voiceTimerDisplayElement.textContent.includes("Error") && !voiceTimerDisplayElement.textContent.includes("Tidak ada suara") ) {
                    voiceTimerDisplayElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        function stopVoiceTimerDisplay() {
            clearInterval(voiceTimerInterval);
             if (voiceTimerDisplayElement) voiceTimerDisplayElement.textContent = '0:00';
        }

        function createActionCards() {
            if (!quickActionsGalleryContainer || !quickActionsDotsContainer) return;
            quickActionsGalleryContainer.innerHTML = '';
            actionCards = [];

            actionCardData.forEach((data, idx) => {
                const card = document.createElement('div');
                card.classList.add('action-card');
                card.dataset.actionId = data.id;
                const iconContainer = document.createElement('div');
                iconContainer.className = 'action-card-icon-container';
                iconContainer.innerHTML = data.svg;
                if (iconContainer.firstChild) {
                    iconContainer.firstChild.style.color = data.color || 'var(--button-bg-color)';
                }

                card.innerHTML = `
                    ${iconContainer.outerHTML}
                    <div class="action-card-info">
                        <h3>${DOMPurify.sanitize(data.title)}</h3>
                        <p class="action-card-subtext"></p> 
                    </div>`;

                card.addEventListener('click', (event) => {
                    if (card.style.pointerEvents === 'none') return;
                    if (isActionCardTransitioning && actionCards.indexOf(card) !== currentActionCardIndex) return;

                    const clickedIndex = actionCards.indexOf(card);
                    if (clickedIndex === currentActionCardIndex) {
                        handleActionCardClick(data.id);
                    } else if (clickedIndex !== -1) {
                        currentActionCardIndex = clickedIndex;
                        updateActionCardCarousel();
                    }
                });
                quickActionsGalleryContainer.appendChild(card);
                actionCards.push(card);
            });
            const centerCardIndex = actionCards.findIndex(card => card.dataset.actionId === "random-question");
            if (centerCardIndex !== -1) {
               currentActionCardIndex = centerCardIndex;
            } else {
               currentActionCardIndex = Math.floor(actionCards.length / 2); 
            }
            updateActionCardCarousel(false);
        }

        function updateActionCardCarousel(animate = true) {
            if (actionCards.length === 0) return;
            if (isActionCardTransitioning && animate) return;
            if (animate) isActionCardTransitioning = true;

            actionCards.forEach((card, index) => {
                card.classList.remove('active', 'prev', 'next', 'far-prev', 'far-next', 'very-far-prev', 'very-far-next');
                const subtextElement = card.querySelector('.action-card-subtext');
                if (subtextElement) subtextElement.textContent = ''; 

                const diff = index - currentActionCardIndex;
                let newPointerEvents = 'none';

                if (diff === 0) { 
                    card.classList.add('active'); 
                    newPointerEvents = 'auto';
                    if (subtextElement) subtextElement.textContent = 'klik saya';
                }
                else if (diff === -1 ) { card.classList.add('prev'); newPointerEvents = 'auto';}
                else if (diff === 1 ) { card.classList.add('next'); newPointerEvents = 'auto';}
                else if (diff === -2) { card.classList.add('far-prev'); }
                else if (diff === 2) { card.classList.add('far-next'); }
                else if (diff < -2) { card.classList.add('very-far-prev'); }
                else if (diff > 2) { card.classList.add('very-far-next'); }

                card.style.pointerEvents = newPointerEvents;
            });

            if (animate) {
                setTimeout(() => { isActionCardTransitioning = false; }, 600);
            }
        }


        function handleActionCardSwipe() {
            if (isActionCardTransitioning) return;
            const swipeXThreshold = 30, swipeYThreshold = 70;
            const deltaX = actionCardTouchEndX - actionCardTouchStartX;
            const deltaY = actionCardTouchEndY - actionCardTouchStartY;

            if (Math.abs(deltaX) > swipeXThreshold && Math.abs(deltaY) < swipeYThreshold) {
                if (deltaX < 0) {
                    currentActionCardIndex = (currentActionCardIndex + 1) % actionCards.length;
                } else {
                    currentActionCardIndex = (currentActionCardIndex - 1 + actionCards.length) % actionCards.length;
                }
                updateActionCardCarousel();
            }
        }

        const actionSuggestions = {
            "buat-gambar": ["gajah Afrika", "robot masa depan", "pemandangan senja di pantai", "kucing bermain piano", "naga terbang di atas gunung"],
            "buat-cerita": ["petualangan di hutan ajaib", "detektif memecahkan misteri", "robot yang punya perasaan", "penjelajah waktu", "persahabatan hewan"],
            "berperan": ["seorang astronot", "koki terkenal", "detektif swasta", "penyihir bijaksana", "penjelajah alam"],
            "berita-terbaru": ["teknologi AI", "penemuan ilmiah", "olahraga sepak bola", "film terbaru", "ekonomi global"],
            "random-question": ["Siapa pembuatmu?", "Kapan kamu dibuat?", "Apa tujuanmu dibuat?", "Ceritakan lelucon", "Apa arti kehidupan?"]
        };

        function handleActionCardClick(actionId) {
            const actionData = actionCardData.find(a => a.id === actionId);
            if (!actionData) return;

            if (actionData.promptPrefix) {
                let fullPrompt = actionData.promptPrefix;
                if (actionSuggestions[actionId] && actionSuggestions[actionId].length > 0) {
                    const randomIndex = Math.floor(Math.random() * actionSuggestions[actionId].length);
                    fullPrompt += actionSuggestions[actionId][randomIndex];
                }
                userInput.value = fullPrompt;
            } else if (actionData.action) {
                switch (actionData.action) {
                    case "analyzeImage":
                        if (imageAttachmentInput) imageAttachmentInput.click();
                        break;
                    case "analyzeFile":
                        if (documentAttachmentInput) documentAttachmentInput.click();
                        break;
                    case "randomQuestion":
                        if (actionSuggestions[actionId] && actionSuggestions[actionId].length > 0) {
                            const randomIndex = Math.floor(Math.random() * actionSuggestions[actionId].length);
                            userInput.value = actionSuggestions[actionId][randomIndex];
                        }
                        break;
                }
            }
            adjustLayout();
            updateSendButtonState();
        }


        function animateWelcomeAndQuickActionsOut(force = false) {
            const elementsToHide = [mainLogoHeader, quickActionsCarouselWrapper, quickActionsTitleContainer];
            let anyVisible = elementsToHide.some(el => el && el.style.display !== 'none' && el.style.opacity !== '0');
            
            const hideAction = () => {
                elementsToHide.forEach(el => {
                    if (el) {
                        el.style.opacity = '0';
                        el.style.transform = 'translateY(20px)';
                    }
                });
                mainWelcomeTextsVisible = false;
                quickActionsAreVisible = false;
                isWelcomeAnimating = false;
                
                setTimeout(() => {
                    elementsToHide.forEach(el => {
                        if (el) el.style.display = 'none';
                    });
                    setButtonStateForProcessing(false); 
                }, 500);
            };
            
            if (force) {
                 elementsToHide.forEach(el => {
                    if (el) {
                        el.style.transition = 'none';
                        el.style.display = 'none';
                        el.style.opacity = '0';
                        el.style.transform = 'translateY(20px)';
                        requestAnimationFrame(() => {
                            el.style.transition = 'opacity 0.5s ease-out, transform 0.5s ease-out';
                        });
                    }
                });
                mainWelcomeTextsVisible = false;
                quickActionsAreVisible = false;
                isWelcomeAnimating = false;
                setButtonStateForProcessing(false);
                
            } else if (anyVisible) {
                hideAction();
            }
        }

        function initWelcomeAndQuickActionsSequence() {
            if (hasChatStarted) {
                animateWelcomeAndQuickActionsOut(true);
                return;
            }

            if (isWelcomeAnimating || mainWelcomeTextsVisible || quickActionsAreVisible) return;

            isWelcomeAnimating = true;
            setButtonStateForProcessing(true);

            if (mainLogoHeader) {
                mainLogoHeader.style.display = 'flex';
                // PERBAIKAN BUG: Paksa reflow sebelum menambahkan kelas transisi
                mainLogoHeader.offsetHeight; 
                mainLogoHeader.classList.add('visible');
            }
            mainWelcomeTextsVisible = true;

            if (quickActionsCarouselWrapper && quickActionsGalleryContainer) {
                createActionCards();
                quickActionsCarouselWrapper.style.display = 'flex';
                 // PERBAIKAN BUG: Paksa reflow sebelum menambahkan kelas transisi
                quickActionsCarouselWrapper.offsetHeight;
                setTimeout(() => {
                    quickActionsCarouselWrapper.classList.add('visible');
                    quickActionsAreVisible = true;
                    isWelcomeAnimating = false;
                    setButtonStateForProcessing(false);
                }, 50); // Penundaan kecil untuk efek stagger
            } else {
                isWelcomeAnimating = false;
                setButtonStateForProcessing(false);
            }
        }
        
        function startEditing(messageId) {
            const historyEntry = chatHistory.find(entry => entry.messageId === messageId);
            if (!historyEntry || historyEntry.role !== 'user') {
                showCustomDialog("Error", "Pesan tidak ditemukan atau tidak dapat diedit.", "alert");
                return;
            }
             if (isEditing) {
                showCustomDialog("Peringatan", "Anda sudah dalam mode edit. Selesaikan atau batalkan editan saat ini terlebih dahulu.", "alert");
                return;
            }

            isEditing = true;
            editingMessageId = messageId;
            const messageElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
            if (messageElement) {
                messageElement.classList.add('editing-hidden');
            }

            clearAllAttachments();

            const textPart = historyEntry.parts.find(p => p.text);
            userInput.value = textPart ? textPart.text : "";
            
            if (historyEntry.attachments && historyEntry.attachments.length > 0) {
                 attachedFiles = historyEntry.attachments.map(att => ({
                    id: `file-edit-${Date.now()}-${Math.random().toString(16).slice(2)}`,
                    type: att.type,
                    name: att.name,
                    dataUrl: att.dataUrl,
                    base64Data: att.base64Data,
                    fileMimeType: att.fileMimeType,
                    previewHTML: att.previewHTML,
                    fileObject: null,
                    extractedText: att.extractedText
                }));
                updateAttachmentPreviewArea();
            }

            editModeIndicatorBar.style.display = 'flex';
            setButtonStateForProcessing(true);
            adjustLayout();
            userInput.focus();
            userInput.setSelectionRange(userInput.value.length, userInput.value.length);
        }

        function cancelEditing() {
            if (!isEditing) return;

            const messageElement = document.querySelector(`.message[data-message-id="${editingMessageId}"]`);
            if (messageElement) {
                messageElement.classList.remove('editing-hidden');
            }

            isEditing = false;
            editingMessageId = null;

            clearAllAttachments();
            userInput.value = "";
            editModeIndicatorBar.style.display = 'none';
            setButtonStateForProcessing(false);
            adjustLayout();
        }
        
        async function submitEdit() {
            if (!isEditing) return;
            const editedText = userInput.value.trim();
            const hasContent = editedText || attachedFiles.length > 0;
            
            if (!hasContent) {
                showCustomDialog("Peringatan", "Pesan yang diedit tidak boleh kosong.", "alert");
                return;
            }
            
            abortGenerationRequested = false;
            currentTurnAbortController = new AbortController();
            const signal = currentTurnAbortController.signal;
            
            const originalMessageUI = document.querySelector(`.message[data-message-id="${editingMessageId}"]`);
            
            if (originalMessageUI) {
                let nextSibling = originalMessageUI.nextElementSibling;
                while (nextSibling) {
                    let toRemove = nextSibling;
                    nextSibling = nextSibling.nextElementSibling;
                    toRemove.remove();
                }
            }
            
            const originalHistoryIndex = chatHistory.findIndex(entry => entry.messageId === editingMessageId);
            if (originalHistoryIndex !== -1) {
                chatHistory.splice(originalHistoryIndex);
                
                const geminiContentParts = [];
                let combinedTextForAI = editedText;
                
                let attachmentsForHistory = [];
                for (const fileData of attachedFiles) {
                    let preparedData = await prepareFileDataForGemini(fileData);
                    if (!preparedData) continue;
                    
                    attachmentsForHistory.push({
                        name: preparedData.name || fileData.name,
                        type: fileData.type,
                        previewHTML: fileData.previewHTML,
                        dataUrl: fileData.dataUrl,
                        fileMimeType: preparedData.mimeType,
                        base64Data: preparedData.base64Data,
                        extractedText: preparedData.extractedText
                    });
                    
                    if (preparedData.base64Data) {
                        geminiContentParts.push({ inlineData: { mimeType: preparedData.mimeType, data: preparedData.base64Data } });
                    } else if (preparedData.extractedText) {
                        combinedTextForAI = `[Konten dari file terlampir: ${preparedData.name}]\n${preparedData.extractedText}\n[Akhir dari konten file: ${preparedData.name}]\n\n${combinedTextForAI}`;
                    }
                }
                
                if (combinedTextForAI.trim()) {
                    geminiContentParts.unshift({ text: combinedTextForAI.trim() });
                }
                
                originalMessageUI.innerHTML = '';
                originalMessageUI.className = 'message user-message';
                originalMessageUI.dataset.messageId = editingMessageId;
                const newContentDiv = document.createElement('div');
                newContentDiv.className = 'message-content';
                let newContentHTML = DOMPurify.sanitize(editedText.replace(/\n/g, '<br>'));
                let attachmentsHTML = '';
                if (attachmentsForHistory.length > 0) {
                    attachmentsHTML = '<div class="user-sent-attachment-display">';
                    attachmentsForHistory.forEach(att => {
                        attachmentsHTML += `<div class="user-sent-attachment-entry" title="${DOMPurify.sanitize(att.name)}">${att.previewHTML}</div>`;
                    });
                    attachmentsHTML += '</div>';
                    newContentHTML = attachmentsHTML + (newContentHTML ? `<br>${newContentHTML}` : "");
                }
                newContentDiv.innerHTML = newContentHTML;
                const editedIndicator = document.createElement('span');
                editedIndicator.className = 'message-edited-indicator';
                editedIndicator.textContent = '(diedit)';
                newContentDiv.appendChild(editedIndicator);
                originalMessageUI.appendChild(newContentDiv);
                originalMessageUI.dataset.copyText = editedText + (attachmentsForHistory.length > 0 ? ` [Lampiran: ${attachmentsForHistory.map(a => a.name).join(', ')}]` : '');
                originalMessageUI.classList.remove('editing-hidden');
                
                const tempEditingMessageId = editingMessageId;
                cancelEditing();
                
                currentTurnUserIntent.messageId = tempEditingMessageId;
                
                getAIResponseAndHandleCommands(geminiContentParts, false, signal);
                
            } else {
                cancelEditing();
                showCustomDialog("Error", "Pesan asli untuk diedit tidak ditemukan. Proses dibatalkan.", "alert");
            }
        }
        
        async function handleRestartAIMessage(messageIdToRestart) {
            console.log("Attempting to restart AI response for message ID:", messageIdToRestart);
            
            let userPromptIndex = -1;
            const aiMessageHistoryIndex = chatHistory.findIndex(entry => entry.messageId === messageIdToRestart && (entry.role === 'model' || entry.role === 'ai'));
            
            if (aiMessageHistoryIndex === -1) {
                showCustomDialog("Error", "Tidak dapat menemukan respons AI yang sesuai di riwayat.", "alert");
                return;
            }
            
            for (let i = aiMessageHistoryIndex - 1; i >= 0; i--) {
                if (chatHistory[i].role === 'user') {
                    userPromptIndex = i;
                    break;
                }
            }
            
            if (userPromptIndex === -1) {
                showCustomDialog("Error", "Tidak dapat menemukan prompt pengguna asli untuk memulai ulang respons ini.", "alert");
                return;
            }
            
            const originalUserEntry = chatHistory[userPromptIndex];
            if (!originalUserEntry || !originalUserEntry.parts) {
                showCustomDialog("Error", "Data prompt pengguna asli tidak lengkap.", "alert");
                return;
            }
            
            let uiMessages = Array.from(chatContainer.querySelectorAll('.message'));
            let aiMessageUIIndex = uiMessages.findIndex(el => el.dataset.messageId === messageIdToRestart);
            if (aiMessageUIIndex !== -1) {
                for (let i = uiMessages.length - 1; i >= aiMessageUIIndex; i--) {
                    if (uiMessages[i].isConnected) uiMessages[i].remove();
                }
            }
            
            chatHistory.splice(aiMessageHistoryIndex);
            
            abortGenerationRequested = false;
            currentTurnAbortController = new AbortController();
            const signal = currentTurnAbortController.signal;
            
            const geminiPartsForResend = [];
            let combinedTextForAI = originalUserEntry.parts.find(p => p.text) ? originalUserEntry.parts.find(p => p.text).text : "";
            
            if (originalUserEntry.attachments && originalUserEntry.attachments.length > 0) {
                for (const attInfo of originalUserEntry.attachments) {
                    if (attInfo.base64Data) {
                        geminiPartsForResend.push({
                            inlineData: { mimeType: attInfo.fileMimeType, data: attInfo.base64Data }
                        });
                    } else if (attInfo.extractedText) {
                        combinedTextForAI = `[Konten dari file terlampir: ${attInfo.name}]\n${attInfo.extractedText}\n[Akhir dari konten file: ${attInfo.name}]\n\n${combinedTextForAI}`;
                    }
                }
            }
            
            if (combinedTextForAI.trim()) {
                geminiPartsForResend.unshift({ text: combinedTextForAI.trim() });
            }
            
            if (geminiPartsForResend.length > 0) {
                console.log("Resending user prompt for restart:", geminiPartsForResend);
                getAIResponseAndHandleCommands(geminiPartsForResend, false, signal);
            } else {
                showCustomDialog("Error", "Tidak dapat membuat ulang prompt pengguna untuk di-restart.", "alert");
                setButtonStateForProcessing(false);
                currentTurnAbortController = null;
            }
        }

        function handleImportChatFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.type !== 'application/json') {
                showCustomDialog("Tipe File Salah", "Hanya file JSON (.json) yang dapat diimpor.", "alert");
                importChatFileInput.value = null;
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedHistory = JSON.parse(e.target.result);
                    if (!Array.isArray(importedHistory)) {
                        throw new Error("Format JSON tidak valid untuk riwayat chat.");
                    }

                    chatHistory = []; 
                    hasChatStarted = true;
                    chatContainer.innerHTML = ''; 

                    importedHistory.forEach(entry => {
                        let userAttachmentsForUI = null;
                        let aiImageAIDataForUI = null;
                        const messageIdForEntry = entry.messageId || `imported-${Date.now()}-${Math.random().toString(16).slice(2)}`;


                        if (entry.role === 'user' && entry.attachments && entry.attachments.length > 0) {
                            userAttachmentsForUI = entry.attachments.map(att => {
                                const iconOrImageHTML = getFileIcon(att.name, att.type);
                                let previewHTMLActual = `<div class="file-icon-preview">${iconOrImageHTML}</div>`;
                                if (att.type === 'image' && att.dataUrl) {
                                    previewHTMLActual = `<img src="${att.dataUrl}" alt="Preview">`;
                                }
                                return { name: att.name, type: att.type, previewHTML: previewHTMLActual, dataUrl: att.dataUrl };
                            });
                        }

                        if (entry.role === 'model' && entry.imageAIDataForUI) {
                            aiImageAIDataForUI = entry.imageAIDataForUI;
                            aiImageAIDataForUI.messageId = messageIdForEntry; 
                        }

                        const messageContent = entry.parts.map(p => p.text || "").join(" ");
                        const messageContentElement = addMessageToUI( 
                            entry.role,
                            messageContent,
                            false, 
                            userAttachmentsForUI,
                            aiImageAIDataForUI,
                            messageIdForEntry,
                            !!aiImageAIDataForUI 
                        );
                        
                        const messageDivElement = messageContentElement.classList.contains('message') ? messageContentElement : messageContentElement.closest('.message');
                        if (messageDivElement && entry.isEdited) {
                            const contentDiv = messageDivElement.querySelector('.message-content');
                            if (contentDiv && !contentDiv.querySelector('.message-edited-indicator')) {
                                const editedIndicator = document.createElement('span');
                                editedIndicator.className = 'message-edited-indicator';
                                editedIndicator.textContent = '(diedit)';
                                contentDiv.appendChild(editedIndicator);
                            }
                        }
                        
                        addMessageToChatHistory(
                            entry.role,
                            entry.parts,
                            entry.attachments, 
                            entry.imageMeta,
                            entry.isProcessedImage,
                            entry.imageAIDataForUI,
                            messageIdForEntry,
                            entry.isEdited
                        );
                    });

                    animateWelcomeAndQuickActionsOut(true); 
                    scrollToBottom(true); 
                    showCustomDialog("Impor Berhasil", "Riwayat chat berhasil diimpor.", "alert");

                } catch (error) {
                    console.error("Error importing chat:", error);
                    showCustomDialog("Error Impor", `Gagal mengimpor riwayat chat: ${error.message}`, "alert");
                } finally {
                    importChatFileInput.value = null;
                }
            };
            reader.readAsText(file);
        }

        function handleMessageMouseDown(e) {
            const targetMessage = e.target.closest('.user-message');
            if (!targetMessage) return;

            isLongPress = false;
            longPressTargetMessageId = targetMessage.dataset.messageId;

            longPressTimer = setTimeout(() => {
                isLongPress = true;
                showUserMessageContextMenu(targetMessage, e);
            }, 500);
        }

        function handleMessageMouseUp(e) {
            clearTimeout(longPressTimer);
            if (isLongPress) {
                e.preventDefault();
            }
            isLongPress = false;
            longPressTargetMessageId = null;
        }

        function showUserMessageContextMenu(targetMessage, event) {
            if (!userMessageContextMenu || isEditing) return;
            
            closeOtherDropdowns(userMessageContextMenu);

            userContextCopyBtn.onclick = () => {
                const textToCopy = targetMessage.dataset.copyText || '';
                navigator.clipboard.writeText(textToCopy).then(() => {
                    showCustomDialog("Sukses", "Pesan disalin ke clipboard.", "alert");
                }).catch(err => {
                    showCustomDialog("Error", "Gagal menyalin pesan.", "alert");
                });
                userMessageContextMenu.style.display = 'none';
            };

            userContextEditBtn.onclick = () => {
                startEditing(targetMessage.dataset.messageId);
                userMessageContextMenu.style.display = 'none';
            };

            userMessageContextMenu.style.display = 'block';
            updateBodyStates();

            const rect = targetMessage.getBoundingClientRect();
            let top, left;

            if (event.type.includes('touch')) {
                top = event.changedTouches[0].clientY;
                left = event.changedTouches[0].clientX;
            } else {
                top = event.clientY;
                left = event.clientX;
            }

            const menuWidth = userMessageContextMenu.offsetWidth;
            const menuHeight = userMessageContextMenu.offsetHeight;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (left + menuWidth > viewportWidth - 10) {
                left = viewportWidth - menuWidth - 10;
            }
            if (top + menuHeight > viewportHeight - 10) {
                top = viewportHeight - menuHeight - 10;
            }
            if (left < 10) left = 10;
            if (top < 10) top = 10;


            userMessageContextMenu.style.top = `${top}px`;
            userMessageContextMenu.style.left = `${left}px`;
        }
        
        // =========================================================================
        // FUNGSI BARU DAN TELAH DIPERBAIKI UNTUK "NEW CHAT"
        // =========================================================================
        function startNewChat() {
            // Tutup dropdown konfirmasi terlebih dahulu
            isNewChatConfirmVisible = false;
            if (newChatConfirmMenu) newChatConfirmMenu.style.display = 'none';

            // Paksa hentikan semua aktivitas yang sedang berjalan jika ada
            if (aiIsCurrentlyResponding || isGeneratingImage || isProcessingImageClientSide || isTextAnimating) {
                handleStopProcessingClick();
            }

            // Lakukan reset setelah jeda singkat untuk memastikan semua proses berhenti
            setTimeout(() => {
                // Reset UI
                if (chatContainer) chatContainer.innerHTML = '';
                
                // Reset state
                chatHistory = [];
                hasChatStarted = false;
                isEditing = false;
                editingMessageId = null;
                clearAllAttachments();
                if (userInput) userInput.value = '';

                // Reset UI elements ke keadaan awal
                if (editModeIndicatorBar) editModeIndicatorBar.style.display = 'none';
                
                // PERBAIKAN BUG: Reset tampilan elemen selamat datang secara eksplisit
                if (mainLogoHeader) {
                    mainLogoHeader.style.display = 'flex';
                    mainLogoHeader.style.opacity = '0';
                    mainLogoHeader.style.transform = 'translateY(20px)';
                    mainLogoHeader.classList.remove('visible');
                }
                if (quickActionsCarouselWrapper) {
                    quickActionsCarouselWrapper.style.display = 'flex';
                    quickActionsCarouselWrapper.style.opacity = '0';
                    quickActionsCarouselWrapper.style.transform = 'translateY(20px)';
                    quickActionsCarouselWrapper.classList.remove('visible');
                }

                setButtonStateForProcessing(false);
                adjustLayout();

                // Tampilkan kembali layar selamat datang dengan animasi
                triggerInitialAnimations();
            }, 100);
        }

        async function openCameraModal() {
            if (!cameraModal || !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showCustomDialog("Error", "Kamera tidak didukung oleh browser Anda.", "alert");
                return;
            }

            openModal(cameraModal);
            cameraLoading.style.display = 'flex';
            cameraLoading.innerHTML = "Membuka kamera...";

            try {
                currentCameraStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                cameraPreview.srcObject = currentCameraStream;
                cameraLoading.style.display = 'none';
            } catch (err) {
                console.error("Error accessing camera:", err);
                cameraLoading.innerHTML = "Gagal mengakses kamera. <br> Periksa izin di browser Anda.";
                // Keep the modal open so the user can see the error
                setTimeout(() => {
                    if (cameraModal.classList.contains('visible')) {
                         closeCameraModal();
                         showCustomDialog("Error Kamera", "Tidak dapat mengakses kamera. Pastikan Anda telah memberikan izin di pengaturan browser Anda.", "alert");
                    }
                }, 2000);
            }
        }

        function closeCameraModal() {
            if (currentCameraStream) {
                currentCameraStream.getTracks().forEach(track => track.stop());
                currentCameraStream = null;
            }
            closeModal(cameraModal);
        }

        function capturePhoto() {
            if (!currentCameraStream || !cameraPreview) return;

            const canvas = document.createElement('canvas');
            canvas.width = cameraPreview.videoWidth;
            canvas.height = cameraPreview.videoHeight;
            const context = canvas.getContext('2d');
            context.drawImage(cameraPreview, 0, 0, canvas.width, canvas.height);

            const dataUrl = canvas.toDataURL('image/jpeg');
            const fileId = `file-${Date.now()}-${Math.random().toString(16).slice(2)}`;
            const fileName = `capture-${new Date().toISOString().replace(/:/g,'-')}.jpg`;

            if (attachedFiles.length >= MAX_ATTACHMENTS) {
                showCustomDialog("Batas Lampiran Tercapai", `Anda hanya dapat melampirkan maksimal ${MAX_ATTACHMENTS} file.`, "alert");
                closeCameraModal();
                return;
            }

            attachedFiles.push({
                id: fileId,
                fileObject: null, 
                type: 'image',
                dataUrl: dataUrl,
                name: fileName,
                base64Data: dataUrl.split(',')[1],
                fileMimeType: 'image/jpeg',
                previewHTML: `<img src="${dataUrl}" alt="Preview">`
            });

            updateAttachmentPreviewArea();
            closeCameraModal();
        }

        function loadChatSessions() {
            // Placeholder - Implementasi bisa ditambahkan di sini jika diperlukan
        }

    </script>
</body>
</html>
                        